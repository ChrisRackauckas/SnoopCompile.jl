var documenterSearchIndex = {"docs":
[{"location":"userimg/#userimg-1","page":"Creating userimg.jl files","title":"Creating userimg.jl files","text":"","category":"section"},{"location":"userimg/#","page":"Creating userimg.jl files","title":"Creating userimg.jl files","text":"If you want to save more precompile information, one option is to create a \"userimg.jl\" file with which to build Julia. This is only supported for @snoopc. Instead of calling SnoopCompile.parcel and SnoopCompile.write, use the following:","category":"page"},{"location":"userimg/#","page":"Creating userimg.jl files","title":"Creating userimg.jl files","text":"# Use these two lines if you want to add to your userimg.jl\npc = SnoopCompile.format_userimg(reverse!(data[2]))\nSnoopCompile.write(\"/tmp/userimg_Images.jl\", pc)","category":"page"},{"location":"userimg/#","page":"Creating userimg.jl files","title":"Creating userimg.jl files","text":"Now move the resulting file to your Julia source directory, and create a userimg.jl file that includes all the package-specific precompile files you want. Then build Julia from source. You should note that your latencies decrease substantially.","category":"page"},{"location":"userimg/#","page":"Creating userimg.jl files","title":"Creating userimg.jl files","text":"There are serious negatives associated with a userimg.jl script:","category":"page"},{"location":"userimg/#","page":"Creating userimg.jl files","title":"Creating userimg.jl files","text":"Your julia build times become very long\nPkg.update() will have no effect on packages that you've built into julia until you next recompile julia itself. Consequently, you may not get the benefit of enhancements or bug fixes.\nFor a package that you sometimes develop, this strategy is very inefficient, because testing a change means rebuilding Julia as well as your package.","category":"page"},{"location":"userimg/#","page":"Creating userimg.jl files","title":"Creating userimg.jl files","text":"A process similar to this one is also performed via PackageCompiler.","category":"page"},{"location":"snoopc/#macro-snoopc-1","page":"Snooping on code generation: @snoopc","title":"Snooping on code generation: @snoopc","text":"","category":"section"},{"location":"snoopc/#","page":"Snooping on code generation: @snoopc","title":"Snooping on code generation: @snoopc","text":"@snoopc has the advantage of working on any modern version of Julia. It \"snoops\" on the code-generation phase of compilation (the 'c' is a reference to code-generation). Note that while native code is not cached, it nevertheless reveals which methods are being compiled.","category":"page"},{"location":"snoopc/#","page":"Snooping on code generation: @snoopc","title":"Snooping on code generation: @snoopc","text":"Note that unlike @snoopi, @snoopc will generate all methods, not just the top-level methods that trigger compilation. (It is redundant to precompile dependent methods, but neither is it harmful.) It is also worth noting that @snoopc requires \"spinning up\" a new Julia process, and so it is a bit slower than @snoopi.","category":"page"},{"location":"snoopc/#","page":"Snooping on code generation: @snoopc","title":"Snooping on code generation: @snoopc","text":"Let's demonstrate @snoopc with a snoop script, in this case for the ColorTypes package:","category":"page"},{"location":"snoopc/#","page":"Snooping on code generation: @snoopc","title":"Snooping on code generation: @snoopc","text":"using SnoopCompile\n\n### Log the compiles\n# This only needs to be run once (to generate \"/tmp/colortypes_compiles.log\")\n\nSnoopCompile.@snoopc \"/tmp/colortypes_compiles.log\" begin\n    using ColorTypes, Pkg\n    include(joinpath(dirname(dirname(pathof(ColorTypes))), \"test\", \"runtests.jl\"))\nend\n\n### Parse the compiles and generate precompilation scripts\n# This can be run repeatedly to tweak the scripts\n\ndata = SnoopCompile.read(\"/tmp/colortypes_compiles.log\")\n\npc = SnoopCompile.parcel(reverse!(data[2]))\nSnoopCompile.write(\"/tmp/precompile\", pc)","category":"page"},{"location":"snoopc/#","page":"Snooping on code generation: @snoopc","title":"Snooping on code generation: @snoopc","text":"As with @snoopi, the \"/tmp/precompile\" folder will now contain a number of *.jl files, organized by package. For each package, you could copy its corresponding *.jl file into the package's src/ directory and include it into the package as described for @snoopi.","category":"page"},{"location":"snoopc/#","page":"Snooping on code generation: @snoopc","title":"Snooping on code generation: @snoopc","text":"There are more complete example illustrating potential options in the examples/ directory.","category":"page"},{"location":"snoopc/#Additional-flags-1","page":"Snooping on code generation: @snoopc","title":"Additional flags","text":"","category":"section"},{"location":"snoopc/#","page":"Snooping on code generation: @snoopc","title":"Snooping on code generation: @snoopc","text":"When calling the @snoopc macro, a new julia process is spawned using the function Base.julia_cmd(). Advanced users may want to tweak the flags passed to this process to suit specific needs. This can be done by passing an array of flags of the form [\"--flag1\", \"--flag2\"] as the first argument to the @snoopc macro. For instance, if you want to pass the --project=/path/to/dir flag to the process, to cause the julia process to load the project specified by the path, a snoop script may look like:","category":"page"},{"location":"snoopc/#","page":"Snooping on code generation: @snoopc","title":"Snooping on code generation: @snoopc","text":"using SnoopCompile\n\nSnoopCompile.@snoopc [\"--project=/path/to/dir\"] \"/tmp/compiles.csv\" begin\n    # ... statement to snoop on\nend\n\n# ... processing the precompile statements","category":"page"},{"location":"reference/#Reference-1","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Interactive-features-1","page":"Reference","title":"Interactive features","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"@snoopi\n@snoopc\n@snoopr\nSnoopCompile.parcel\nSnoopCompile.write\nSnoopCompile.read\nSnoopCompile.format_userimg\nuinvalidated\ninvalidation_trees\nfiltermod\nfindcaller","category":"page"},{"location":"reference/#SnoopCompileCore.@snoopi","page":"Reference","title":"SnoopCompileCore.@snoopi","text":"inf_timing = @snoopi commands\ninf_timing = @snoopi tmin=0.0 commands\n\nExecute commands while snooping on inference. Returns an array of (t, linfo) tuples, where t is the amount of time spent infering linfo (a MethodInstance).\n\nMethods that take less time than tmin will not be reported.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#SnoopCompileCore.@snoopc","page":"Reference","title":"SnoopCompileCore.@snoopc","text":"@snoopc \"compiledata.csv\" begin\n    # Commands to execute, in a new process\nend\n\ncauses the julia compiler to log all functions compiled in the course of executing the commands to the file \"compiledata.csv\". This file can be used for the input to SnoopCompile.read.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#SnoopCompileCore.@snoopr","page":"Reference","title":"SnoopCompileCore.@snoopr","text":"list = @snoopr expr\n\nCapture method cache invalidations triggered by evaluating expr. list is a sequence of invalidated Core.MethodInstances together with \"explanations,\" consisting of integers (encoding depth) and strings (documenting the source of an invalidation).\n\nUnless you are working at a low level, you essentially always want to pass list directly to SnoopCompile.invalidation_trees.\n\nExtended help\n\nlist is in a format where the \"reason\" comes after the items. Method deletion results in the sequence\n\n[zero or more (mi, \"invalidate_mt_cache\") pairs..., zero or more (depth1 tree, loctag) pairs..., method, loctag] with loctag = \"jl_method_table_disable\"\n\nwhere mi means a MethodInstance. depth1 means a sequence starting at depth=1.\n\nMethod insertion results in the sequence\n\n[zero or more (depth0 tree, sig) pairs..., same info as with delete_method except loctag = \"jl_method_table_insert\"]\n\n\n\n\n\n","category":"macro"},{"location":"reference/#SnoopCompile.parcel","page":"Reference","title":"SnoopCompile.parcel","text":"pc = parcel(calls; subst=[], exclusions=[]) assigns each compile statement to the module that owns the function. Perform string substitution via subst=[\"Module1\"=>\"Module2\"], and omit functions in particular modules with exclusions=[\"Module3\"]. On output, pc[:Module2] contains all the precompiles assigned to Module2.\n\nUse SnoopCompile.write(prefix, pc) to generate a series of files in directory prefix, one file per module.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SnoopCompile.write","page":"Reference","title":"SnoopCompile.write","text":"write(prefix::AbstractString, pc::Dict; always::Bool = false)\n\nWrite each modules' precompiles to a separate file.  If always is true, the generated function will always run the precompile statements when called, otherwise the statements will only be called during package precompilation.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SnoopCompile.read","page":"Reference","title":"SnoopCompile.read","text":"SnoopCompile.read(\"compiledata.csv\") reads the log file produced by the compiler and returns the functions as a pair of arrays. The first array is the amount of time required to compile each function, the second is the corresponding function + types. The functions are sorted in order of increasing compilation time. (The time does not include the cost of nested compiles.)\n\n\n\n\n\n","category":"function"},{"location":"reference/#SnoopCompile.format_userimg","page":"Reference","title":"SnoopCompile.format_userimg","text":"pc = format_userimg(calls; subst=[], exclusions=[]) generates precompile directives intended for your base/userimg.jl script. Use SnoopCompile.write(filename, pc) to create a file that you can include into userimg.jl.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SnoopCompile.uinvalidated","page":"Reference","title":"SnoopCompile.uinvalidated","text":"umis = uinvalidated(invlist)\n\nReturn the unique invalidated MethodInstances. invlist is obtained from SnoopCompileCore.@snoopr. This is similar to filtering for MethodInstances in invlist, except that it discards any tagged \"invalidate_mt_cache\". These can typically be ignored because they are nearly inconsequential: they do not invalidate any compiled code, they only transiently affect an optimization of runtime dispatch.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SnoopCompile.invalidation_trees","page":"Reference","title":"SnoopCompile.invalidation_trees","text":"trees = invalidation_trees(list)\n\nParse list, as captured by SnoopCompileCore.@snoopr, into a set of invalidation trees, where parents nodes were called by their children.\n\nExample\n\njulia> f(x::Int)  = 1\nf (generic function with 1 method)\n\njulia> f(x::Bool) = 2\nf (generic function with 2 methods)\n\njulia> applyf(container) = f(container[1])\napplyf (generic function with 1 method)\n\njulia> callapplyf(container) = applyf(container)\ncallapplyf (generic function with 1 method)\n\njulia> c = Any[1]\n1-element Array{Any,1}:\n 1\n\njulia> callapplyf(c)\n1\n\njulia> trees = invalidation_trees(@snoopr f(::AbstractFloat) = 3)\n1-element Array{SnoopCompile.MethodInvalidations,1}:\n inserting f(::AbstractFloat) in Main at REPL[36]:1 invalidated:\n   mt_backedges: 1: signature Tuple{typeof(f),Any} triggered MethodInstance for applyf(::Array{Any,1}) (1 children) more specific\n\nSee the documentation for further details.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SnoopCompile.filtermod","page":"Reference","title":"SnoopCompile.filtermod","text":"thinned = filtermod(module, trees::AbstractVector{MethodInvalidations})\n\nSelect just the cases of invalidating a method defined in module.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SnoopCompile.findcaller","page":"Reference","title":"SnoopCompile.findcaller","text":"methinvs = findcaller(method::Method, trees)\n\nFind a path through trees that reaches method. Returns a single MethodInvalidations object.\n\nExamples\n\nSuppose you know that loading package SomePkg triggers invalidation of f(data). You can find the specific source of invalidation as follows:\n\nf(data)                             # run once to force compilation\nm = @which f(data)\nusing SnoopCompile\ntrees = invalidation_trees(@snoopr using SomePkg)\nmethinvs = findcaller(m, trees)\n\nIf you don't know which method to look for, but know some operation that has had added latency, you can look for methods using @snoopi. For example, suppose that loading SomePkg makes the next using statement slow. You can find the source of trouble with\n\njulia> using SnoopCompile\n\njulia> trees = invalidation_trees(@snoopr using SomePkg);\n\njulia> tinf = @snoopi using SomePkg            # this second `using` will need to recompile code invalidated above\n1-element Array{Tuple{Float64,Core.MethodInstance},1}:\n (0.08518409729003906, MethodInstance for require(::Module, ::Symbol))\n\njulia> m = tinf[1][2].def\nrequire(into::Module, mod::Symbol) in Base at loading.jl:887\n\njulia> findcaller(m, trees)\ninserting ==(x, y::SomeType) in SomeOtherPkg at /path/to/code:100 invalidated:\n   backedges: 1: superseding ==(x, y) in Base at operators.jl:83 with MethodInstance for ==(::Symbol, ::Any) (16 children) more specific\n\n\n\n\n\n","category":"function"},{"location":"#SnoopCompile.jl-1","page":"SnoopCompile.jl","title":"SnoopCompile.jl","text":"","category":"section"},{"location":"#","page":"SnoopCompile.jl","title":"SnoopCompile.jl","text":"SnoopCompile \"snoops\" on the Julia compiler, causing it to record the functions and argument types it's compiling.  From these lists of methods, you can generate lists of precompile directives that may reduce the latency between loading packages and using them to do \"real work.\"","category":"page"},{"location":"#","page":"SnoopCompile.jl","title":"SnoopCompile.jl","text":"SnoopCompile can also detect and analyze method cache invalidations, which occur when new method definitions alter dispatch in a way that forces Julia to discard previously-compiled code. Any later usage of invalidated methods requires recompilation. Invalidation can trigger a domino effect, in which all users of invalidated code also become invalidated, propagating all the way back to the top-level call. When a source of invalidation can be identified and either eliminated or mitigated, you can reduce the amount of work that the compiler needs to repeat and take better advantage of precompilation.","category":"page"},{"location":"#Background-1","page":"SnoopCompile.jl","title":"Background","text":"","category":"section"},{"location":"#","page":"SnoopCompile.jl","title":"SnoopCompile.jl","text":"Julia uses Just-in-time (JIT) compilation to generate the code that runs on your CPU. Broadly speaking, there are two major steps: inference and code generation. Inference is the process of determining the type of each object, which in turn determines which specific methods get called; once type inference is complete, code generation performs optimizations and ultimately generates the assembly language (native code) used on CPUs. Some aspects of this process are documented here.","category":"page"},{"location":"#","page":"SnoopCompile.jl","title":"SnoopCompile.jl","text":"Every time you load a package in a fresh Julia session, the methods you use need to be JIT-compiled, and this contributes to the latency of using the package. In some circumstances, you can save some of the work to reduce the burden next time. This is called precompilation. Unfortunately, precompilation is not as comprehensive as one might hope. Currently, Julia is only capable of saving inference results (not native code) in the *.ji files that are the result of precompilation. Moreover, there are some significant constraints that sometimes prevent Julia from saving even the inference results; and finally, what does get saved can sometimes be invalidated if later packages provide more specific methods that supersede some of the calls in the precompiled methods.","category":"page"},{"location":"#","page":"SnoopCompile.jl","title":"SnoopCompile.jl","text":"Despite these limitations, there are cases where precompilation can substantially reduce latency. SnoopCompile is designed to try to make it easy to try precompilation to see whether it produces measurable benefits.","category":"page"},{"location":"#Who-should-use-this-package-1","page":"SnoopCompile.jl","title":"Who should use this package","text":"","category":"section"},{"location":"#","page":"SnoopCompile.jl","title":"SnoopCompile.jl","text":"SnoopCompile is intended primarily for package developers who want to improve the experience for their users. Because the results of SnoopCompile are typically stored in the *.ji precompile files, anyone can take advantage of the reduced latency.","category":"page"},{"location":"#","page":"SnoopCompile.jl","title":"SnoopCompile.jl","text":"PackageCompiler is an alternative that non-developer users may want to consider for their own workflow. It performs more thorough precompilation than the \"standard\" usage of SnoopCompile, although one can achieve a similar effect by creating userimg.jl files. However, the cost is vastly increased build times, which for package developers is unlikely to be productive.","category":"page"},{"location":"#","page":"SnoopCompile.jl","title":"SnoopCompile.jl","text":"Finally, another alternative that reduces latency without any modifications to package files is Revise. It can be used in conjunction with SnoopCompile.","category":"page"},{"location":"snoopi/#macro-snoopi-1","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"","category":"section"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"The most useful tool is a macro, @snoopi, which is only available on Julia 1.2 or higher.","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"Julia can cache inference results, so you can use @snoopi to generate precompile directives for your package. Executing these directives when the package is compiled may reduce compilation (inference) time when the package is used.","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"Here's a quick demo:","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"using SnoopCompile\n\na = rand(Float16, 5)\n\njulia> inf_timing = @snoopi sum(a)\n1-element Array{Tuple{Float64,Core.MethodInstance},1}:\n (0.011293888092041016, MethodInstance for sum(::Array{Float16,1}))","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"We defined the argument a, and then called sum(a) while \"snooping\" on inference. (The i in @snoopi means \"inference.\") The return is a list of \"top level\" methods that got compiled, together with the amount of time spent on inference. In this case it was just a single method, which required approximately 11ms of inference time. (Inferring sum required inferring all the methods that it calls, but these are subsumed into the top level inference of sum itself.) Note that the method that got called,","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"julia> @which sum(a)\nsum(a::AbstractArray) in Base at reducedim.jl:652","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"is much more general (i.e., defined for AbstractArray) than the MethodInstance (defined for Array{Float16,1}). This is because precompilation happens only for concrete objects passed as arguments.","category":"page"},{"location":"snoopi/#pcscripts-1","page":"Snooping on inference: @snoopi","title":"Precompile scripts","text":"","category":"section"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"You can use @snoopi to come up with a list of precompile-worthy functions. A recommended approach is to write a script that \"exercises\" the functionality you'd like to precompile. One option is to use your package's \"runtests.jl\" file, or you can write a custom script for this purpose. Here's an example for the FixedPointNumbers package:","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"using FixedPointNumbers\n\nx = N0f8(0.2)\ny = x + x\ny = x - x\ny = x*x\ny = x/x\ny = Float32(x)\ny = Float64(x)\ny = 0.3*x\ny = x*0.3\ny = 2*x\ny = x*2\ny = x/15\ny = x/8.0","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"Save this as a file \"snoopfpn.jl\" and navigate at the Julia REPL to that directory, and then do","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"julia> using SnoopCompile\n\njulia> inf_timing = @snoopi tmin=0.01 include(\"snoopfpn.jl\")\n2-element Array{Tuple{Float64,Core.MethodInstance},1}:\n (0.03108978271484375, MethodInstance for *(::Normed{UInt8,8}, ::Normed{UInt8,8}))\n (0.04189491271972656, MethodInstance for Normed{UInt8,8}(::Float64))","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"Here, note the tmin=0.01, which causes any methods that take less than 10ms of inference time to be discarded.","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"note: Note\nIf you're testing this, you might get different results depending on the speed of your machine. Moreover, if FixedPointNumbers has already precompiled these method and type combinations–-perhaps by incorporating a precompile file produced by SnoopCompile–-then those methods will be absent. If you want to try this example, dev FixedPointNumbers and disable any _precompile_() call you find.","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"You can inspect these results and write your own precompile file, or use the automated tools provided by SnoopCompile.","category":"page"},{"location":"snoopi/#auto-1","page":"Snooping on inference: @snoopi","title":"Producing precompile directives automatically","text":"","category":"section"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"You can take the output of @snoopi and \"parcel\" it into packages:","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"julia> pc = SnoopCompile.parcel(inf_timing)\nDict{Symbol,Array{String,1}} with 1 entry:\n  :FixedPointNumbers => [\"precompile(Tuple{typeof(*),Normed{UInt8,8},Normed{UInt8,8}})\", \"precompile(Tuple{Type{Normed{UInt8,8}},Float64})\"]","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"This splits the calls up into a dictionary, pc, indexed by the package which \"owns\" each call. (In this case there is only one, FixedPointNumbers, but in more complex cases there may be several.) You can then write the results to files:","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"julia> SnoopCompile.write(\"/tmp/precompile\", pc)","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"If you look in the /tmp/precompile directory, you'll see one or more files, named by their parent package, that may be suitable for includeing into the package. In this case:","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"/tmp/precompile$ cat precompile_FixedPointNumbers.jl\nfunction _precompile_()\n    ccall(:jl_generating_output, Cint, ()) == 1 || return nothing\n    precompile(Tuple{typeof(*),Normed{UInt8,8},Normed{UInt8,8}})\n    precompile(Tuple{Type{Normed{UInt8,8}},Float64})\nend","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"If you copy this file to a precompile.jl file in the src directory, you can incorporate it into the package like this:","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"module FixedPointNumbers\n\n# All the usual commands that define the module go here\n\n# ... followed by:\n\ninclude(\"precompile.jl\")\n_precompile_()\n\nend # module FixedPointNumbers","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"The listed method/type combinations should have their inference results cached. Load the package once to precompile it, and then in a fresh Julia session try this:","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"julia> using SnoopCompile\n\njulia> inf_timing = @snoopi tmin=0.01 include(\"snoopfpn.jl\")\n0-element Array{Tuple{Float64,Core.MethodInstance},1}","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"The fact that no methods were returned is a sign of success: Julia didn't need to call inference on those methods, because it used the inference results from the cache file.","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"note: Note\nSometimes, @snoopi will show method & type combinations that you precompiled. This is a sign that despite your attempts, Julia declined to cache the inference results for those methods. You can either delete those directives from the precompile file, or hope that they will become useful in a future version of Julia. Note that having many \"useless\" precompile directives can slow down precompilation.","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"note: Note\nAs you develop your package, it's possible you'll modify or delete some of the methods that appear in your \"precompile.jl\" file. This will not result in an error; by default precompile fails silently. If you want to be certain that your precompile directives don't go stale, preface each with an @assert. Note that this forces you to update your precompile directives as you modify your package, which may or may not be desirable.","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"If you find that some precompile directives are ineffective (they appear in a new @snoopi despite being precompiled) and their inference time is substantial, sometimes a bit of manual investigation of the callees can lead to insights. For example, you might be able to introduce a precompile in a dependent package that can mitigate the total time.","category":"page"},{"location":"snoopi/#Producing-precompile-directives-manually-1","page":"Snooping on inference: @snoopi","title":"Producing precompile directives manually","text":"","category":"section"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"While this \"automated\" approach is often useful, sometimes it makes more sense to inspect the results and write your own precompile directives. For example, for FixedPointNumbers a more elegant and comprehensive precompile file might be","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"function _precompile_()\n    ccall(:jl_generating_output, Cint, ()) == 1 || return nothing\n    for T in (N0f8, N0f16)      # Normed types we want to support\n        for f in (+, -, *, /)   # operations we want to support\n            precompile(Tuple{typeof(f),T,T})\n            for S in (Float32, Float64, Int)   # other number types we want to support\n                precompile(Tuple{typeof(f),T,S})\n                precompile(Tuple{typeof(f),S,T})\n            end\n        end\n        for S in (Float32, Float64)\n            precompile(Tuple{Type{T},S})\n            precompile(Tuple{Type{S},T})\n        end\n    end\nend","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"This covers +, -, *, /, and conversion for various combinations of types. The results from @snoopi can suggest method/type combinations that might be useful to precompile, but often you can generalize its suggestions in useful ways.","category":"page"},{"location":"snoopi/#Analyzing-omitted-methods-1","page":"Snooping on inference: @snoopi","title":"Analyzing omitted methods","text":"","category":"section"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"There are some method signatures that cannot be precompiled. For example, suppose you have two packages, A and B, that are independent of one another. Then A.f([B.Object(1)]) cannot be precompiled, because A does not know about B.Object, and B does not know about A.f, unless both A and B get included into a third package.","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"Such problematic method signatures are removed automatically. If you want to be informed about these removals, you can use Julia's logging framework while running parcel:","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"julia> using Base.CoreLogging\n\njulia> logger = SimpleLogger(IOBuffer(), CoreLogging.Debug);\n\njulia> pc = with_logger(logger) do\n           SnoopCompile.parcel(inf_timing)\n       end\n\njulia> msgs = String(take!(logger.stream))","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"The omitted method signatures will be logged to the string msgs.","category":"page"},{"location":"snoopr/#Snooping-on-and-fixing-invalidations:-@snoopr-1","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"","category":"section"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"note: Note\n@snoopr is available on Julia 1.6.0-DEV.154 or above, but the results can be relevant for all Julia versions.","category":"page"},{"location":"snoopr/#Recording-invalidations-1","page":"Snooping on and fixing invalidations: @snoopr","title":"Recording invalidations","text":"","category":"section"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"DocTestFilters = r\"(REPL\\[\\d+\\]|none):\\d+\"\nDocTestSetup = quote\n    using SnoopCompile\nend","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"Invalidations occur when there is a danger that new methods would supersede older methods in previously-compiled code.","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"To record the invalidations caused by defining new methods, use @snoopr. @snoopr is exported by SnoopCompile, but the recommended approach is to record invalidations using the minimalistic SnoopCompileCore package, and then load SnoopCompile to do the analysis:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"using SnoopCompileCore\ninvalidations = @snoopr begin\n    # package loads and/or method definitions that might invalidate other code\nend\nusing SnoopCompile   # now that we've collected the data, load the complete package to analyze the results","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"note: Note\nSnoopCompileCore was split out from SnoopCompile to reduce the risk of invalidations from loading SnoopCompile itself. Once a MethodInstance gets invalidated, it doesn't show up in future @snoopr results, so anything that gets invalidated in order to provide @snoopr would be omitted from the results. SnoopCompileCore is a very small package with no dependencies and which avoids extending any of Julia's own functions, so it cannot invalidate any other code.","category":"page"},{"location":"snoopr/#Analyzing-invalidations-1","page":"Snooping on and fixing invalidations: @snoopr","title":"Analyzing invalidations","text":"","category":"section"},{"location":"snoopr/#A-first-example-1","page":"Snooping on and fixing invalidations: @snoopr","title":"A first example","text":"","category":"section"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"We'll walk through this process with the following example:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"julia> f(::Real) = 1;\n\njulia> callf(container) = f(container[1]);\n\njulia> call2f(container) = callf(container);","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"Because code doesn't get compiled until it gets run, and invalidations only affect compiled code, let's run this with different container types:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"julia> c64  = [1.0]; c32 = [1.0f0]; cabs = AbstractFloat[1.0];\n\njulia> call2f(c64)\n1\n\njulia> call2f(c32)\n1\n\njulia> call2f(cabs)\n1","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"warning: Warning\nIf you're following along, be sure you actually execute these methods, or you won't obtain the results below.","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"Now we'll define a new f method, one specialized for Float64. So we can see the consequences for the compiled code, we'll make this definition while snooping on the compiler with @snoopr:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"julia> using SnoopCompileCore\n\njulia> invalidations = @snoopr f(::Float64) = 2;\n\njulia> using SnoopCompile","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"The simplest thing we can do is list or count invalidations:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"julia> length(uinvalidated(invalidations))  # collect the unique MethodInstances & count them\n6","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"The length of this set is your simplest insight into the extent of invalidations triggered by this method definition.","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"If you want to fix invalidations, it's crucial to know why certain MethodInstances were invalidated. For that, it's best to use a tree structure, in which children are invalidated because their parents get invalidated:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"julia> trees = invalidation_trees(invalidations)\n1-element Vector{SnoopCompile.MethodInvalidations}:\n inserting f(::Float64) in Main at REPL[9]:1 invalidated:\n   backedges: 1: superseding f(::Real) in Main at REPL[2]:1 with MethodInstance for f(::Float64) (2 children)\n              2: superseding f(::Real) in Main at REPL[2]:1 with MethodInstance for f(::AbstractFloat) (2 children)","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"The output, trees, is a vector of MethodInvalidations, a data type defined in SnoopCompile; each of these is the set of invalidations triggered by a particular method definition. In this case, we only defined one method, so we can get at most one MethodInvalidation. @snoopr using SomePkg might result in a list of such objects, each connected to a particular method defined in a particular package (either SomePkg itself or one of its dependencies).","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"In this case, \"inserting f(::Float64)\" indicates that we added a method with signature f(::Float64), and that this method triggered invalidations. (Invalidations can also be triggered by method deletion, although this should not happen in typical usage.) Next, notice the backedges line, and the fact that there are two items listed for it. This indicates that there were two proximal triggers for the invalidation, both of which superseded the method f(::Real). One of these had been compiled specifically for Float64, due to our call2f(c64). The other had been compiled specifically for AbstractFloat, due to our call2f(cabs).","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"You can look at these invalidation trees in greater detail:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"julia> method_invalidations = trees[1];    # invalidations stemming from a single method\n\njulia> root = method_invalidations.backedges[1]  # get the first triggered invalidation\nMethodInstance for f(::Float64) at depth 0 with 2 children\n\njulia> show(root)\nMethodInstance for f(::Float64) (2 children)\n MethodInstance for callf(::Vector{Float64}) (1 children)\n ⋮\n\njulia> show(root; minchildren=0)\nMethodInstance for f(::Float64) (2 children)\n MethodInstance for callf(::Vector{Float64}) (1 children)\n  MethodInstance for call2f(::Vector{Float64}) (0 children)","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"The indentation here reveals that call2f called callf which called f, and shows the entire \"chain\" of invalidations triggered by this method definition. Examining root2 = method_invalidations.backedges[2] yields similar results, but for Vector{AbstractFloat}.","category":"page"},{"location":"snoopr/#mt_backedges-invalidations-1","page":"Snooping on and fixing invalidations: @snoopr","title":"mt_backedges invalidations","text":"","category":"section"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"MethodInvalidations can have a second field, mt_backedges. These are invalidations triggered via the MethodTable for a particular function. When extracting mt_backedges, in addition to a root MethodInstance these also indicate a particular signature that triggered the invalidation. We can illustrate this by returning to the call2f example above:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"julia> call2f([\"hello\"])\nERROR: MethodError: no method matching f(::String)\n[...]\n\njulia> invalidations = @snoopr f(::AbstractString) = 2;\n\njulia> trees = invalidation_trees(invalidations)\n1-element Vector{SnoopCompile.MethodInvalidations}:\n inserting f(::AbstractString) in Main at REPL[6]:1 invalidated:\n   mt_backedges: 1: signature Tuple{typeof(f),String} triggered MethodInstance for callf(::Vector{String}) (1 children)\n\n\njulia> sig, root = trees[1].mt_backedges[end];\n\njulia> sig\nTuple{typeof(f),String}\n\njulia> root\nMethodInstance for callf(::Vector{String}) at depth 0 with 1 children","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"You can see that the invalidating signature, f(::String), is more specific than the signature of the defined method, but that it is what was minimally needed by callf(::Vector{String}).","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"mt_backedges invalidations often reflect \"unhandled\" conditions in methods that have already been compiled.","category":"page"},{"location":"snoopr/#A-more-complex-example-1","page":"Snooping on and fixing invalidations: @snoopr","title":"A more complex example","text":"","category":"section"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"The structure of these trees can be considerably more complicated. For example, if callf also got called by some other method, and that method had also been executed (forcing it to be compiled), then callf would have multiple children. This is often seen with more complex, real-world tests. As a medium-complexity example, try the following:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"julia> using Revise\n\njulia> using SnoopCompileCore\n\njulia> invalidations = @snoopr using FillArrays;\n\njulia> using SnoopCompile\n\njulia> trees = invalidation_trees(invalidations)\n3-element Vector{SnoopCompile.MethodInvalidations}:\n inserting all(f::Function, x::FillArrays.AbstractFill) in FillArrays at /home/tim/.julia/packages/FillArrays/NjFh2/src/FillArrays.jl:556 invalidated:\n   backedges: 1: superseding all(f::Function, a::AbstractArray; dims) in Base at reducedim.jl:880 with MethodInstance for all(::Base.var\"#388#389\"{_A} where _A, ::AbstractArray) (3 children)\n              2: superseding all(f, itr) in Base at reduce.jl:918 with MethodInstance for all(::Base.var\"#388#389\"{_A} where _A, ::Any) (3 children)\n\n inserting any(f::Function, x::FillArrays.AbstractFill) in FillArrays at /home/tim/.julia/packages/FillArrays/NjFh2/src/FillArrays.jl:555 invalidated:\n   backedges: 1: superseding any(f::Function, a::AbstractArray; dims) in Base at reducedim.jl:877 with MethodInstance for any(::typeof(ismissing), ::AbstractArray) (1 children)\n              2: superseding any(f, itr) in Base at reduce.jl:871 with MethodInstance for any(::typeof(ismissing), ::Any) (1 children)\n              3: superseding any(f, itr) in Base at reduce.jl:871 with MethodInstance for any(::LoweredCodeUtils.var\"#11#12\"{_A} where _A, ::Any) (2 children)\n              4: superseding any(f::Function, a::AbstractArray; dims) in Base at reducedim.jl:877 with MethodInstance for any(::LoweredCodeUtils.var\"#11#12\"{_A} where _A, ::AbstractArray) (4 children)\n\n inserting broadcasted(::Base.Broadcast.DefaultArrayStyle{N}, op, r::FillArrays.AbstractFill{T,N,Axes} where Axes) where {T, N} in FillArrays at /home/tim/.julia/packages/FillArrays/NjFh2/src/fillbroadcast.jl:8 invalidated:\n   backedges: 1: superseding broadcasted(::S, f, args...) where S<:Base.Broadcast.BroadcastStyle in Base.Broadcast at broadcast.jl:1265 with MethodInstance for broadcasted(::Base.Broadcast.BroadcastStyle, ::typeof(JuliaInterpreter._Typeof), ::Any) (1 children)\n              2: superseding broadcasted(::S, f, args...) where S<:Base.Broadcast.BroadcastStyle in Base.Broadcast at broadcast.jl:1265 with MethodInstance for broadcasted(::Base.Broadcast.BroadcastStyle, ::typeof(string), ::AbstractArray) (177 children)","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"Your specific results may differ from this, depending on which version of Julia and of packages you are using. In this case, you can see that three methods (one for all, one for any, and one for broadcasted) triggered invalidations. Perusing this list, you can see that methods in Base, LoweredCodeUtils, and JuliaInterpreter (the latter two were loaded by Revise) got invalidated by methods defined in FillArrays.","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"The most consequential ones (the ones with the most children) are listed last, and should be where you direct your attention first. That last entry looks particularly problematic, so let's extract it:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"julia> methinvs = trees[end];\n\njulia> root = methinvs.backedges[end]\nMethodInstance for broadcasted(::Base.Broadcast.BroadcastStyle, ::typeof(string), ::AbstractArray) at depth 0 with 177 children\n\njulia> show(root; maxdepth=10)\nMethodInstance for broadcasted(::Base.Broadcast.BroadcastStyle, ::typeof(string), ::AbstractArray) (177 children)\n MethodInstance for broadcasted(::typeof(string), ::AbstractArray) (176 children)\n  MethodInstance for #unpack#104(::Bool, ::typeof(Pkg.PlatformEngines.unpack), ::String, ::String) (175 children)\n   MethodInstance for (::Pkg.PlatformEngines.var\"#unpack##kw\")(::NamedTuple{(:verbose,),Tuple{Bool}}, ::typeof(Pkg.PlatformEngines.unpack), ::String, ::String) (174 children)\n    MethodInstance for #download_verify_unpack#109(::Nothing, ::Bool, ::Bool, ::Bool, ::Bool, ::typeof(Pkg.PlatformEngines.download_verify_unpack), ::String, ::Nothing, ::String) (165 children)\n     MethodInstance for (::Pkg.PlatformEngines.var\"#download_verify_unpack##kw\")(::NamedTuple{(:ignore_existence, :verbose),Tuple{Bool,Bool}}, ::typeof(Pkg.PlatformEngines.download_verify_unpack), ::String, ::Nothing, ::String) (33 children)\n      MethodInstance for (::Pkg.Artifacts.var\"#39#40\"{Bool,String,Nothing})(::String) (32 children)\n       MethodInstance for create_artifact(::Pkg.Artifacts.var\"#39#40\"{Bool,String,Nothing}) (31 children)\n        MethodInstance for #download_artifact#38(::Bool, ::Bool, ::typeof(Pkg.Artifacts.download_artifact), ::Base.SHA1, ::String, ::Nothing) (30 children)\n         MethodInstance for (::Pkg.Artifacts.var\"#download_artifact##kw\")(::NamedTuple{(:verbose, :quiet_download),Tuple{Bool,Bool}}, ::typeof(Pkg.Artifacts.download_artifact), ::Base.SHA1, ::String, ::Nothing) (23 children)\n          MethodInstance for (::Pkg.Artifacts.var\"#download_artifact##kw\")(::NamedTuple{(:verbose, :quiet_download),Tuple{Bool,Bool}}, ::typeof(Pkg.Artifacts.download_artifact), ::Base.SHA1, ::String) (22 children)\n          ⋮\n        ⋮\n     MethodInstance for (::Pkg.PlatformEngines.var\"#download_verify_unpack##kw\")(::NamedTuple{(:ignore_existence,),Tuple{Bool}}, ::typeof(Pkg.PlatformEngines.download_verify_unpack), ::String, ::Nothing, ::String) (130 children)\n      MethodInstance for (::Pkg.Types.var\"#94#97\"{Pkg.Types.Context,String,Pkg.Types.RegistrySpec})(::String) (116 children)\n       MethodInstance for #mktempdir#21(::String, ::typeof(mktempdir), ::Pkg.Types.var\"#94#97\"{Pkg.Types.Context,String,Pkg.Types.RegistrySpec}, ::String) (115 children)\n        MethodInstance for mktempdir(::Pkg.Types.var\"#94#97\"{Pkg.Types.Context,String,Pkg.Types.RegistrySpec}, ::String) (114 children)\n         MethodInstance for mktempdir(::Pkg.Types.var\"#94#97\"{Pkg.Types.Context,String,Pkg.Types.RegistrySpec}) (113 children)\n          MethodInstance for clone_or_cp_registries(::Pkg.Types.Context, ::Vector{Pkg.Types.RegistrySpec}, ::String) (112 children)\n          ⋮\n     ⋮\n   ⋮","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"Here you can see a much more complex branching structure. From this, you can see that methods in Pkg are the most significantly affected; you could expect that loading FillArrays might slow down your next Pkg operation (perhaps depending on which operation you choose) executed in this same session.","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"Again, if you're following along, it's possible that you'll see something quite different, if subsequent development has protected Pkg against this form of invalidation.","category":"page"},{"location":"snoopr/#Filtering-invalidations-1","page":"Snooping on and fixing invalidations: @snoopr","title":"Filtering invalidations","text":"","category":"section"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"Some method definitions trigger widespread invalidation. If you don't have time to fix all of them, you might want to focus on a specific set of invalidations. For instance, you might be the author of PkgA and you've noted that loading PkgB invalidates a lot of PkgA's code. In that case, you might want to find just those invalidations triggered in your package. You can find them with filtermod:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"trees = invalidation_trees(@snoopr using PkgB)\nftrees = filtermod(PkgA, trees)","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"filtermod only selects trees where the root method was defined in the specified module.","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"A more selective yet exhaustive tool is findcaller, which allows you to find the path through the trees to a particular method:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"m = @which f(data)                  # look for the \"path\" that invalidates this method\nf(data)                             # run once to force compilation\nusing SnoopCompile\ntrees = invalidation_trees(@snoopr using SomePkg)\ninvs = findcaller(m, trees)         # select the branch that invalidated a compiled instance of `m`","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"When you don't know which method to choose, but know an operation that got slowed down by loading SomePkg, you can use @snoopi to find methods that needed to be recompiled. See findcaller for further details.","category":"page"},{"location":"snoopr/#Fixing-invalidations-1","page":"Snooping on and fixing invalidations: @snoopr","title":"Fixing invalidations","text":"","category":"section"},{"location":"snoopr/#ascend-1","page":"Snooping on and fixing invalidations: @snoopr","title":"ascend","text":"","category":"section"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"SnoopCompile, partnering with the remarkable Cthulhu, provides a tool called ascend to simplify diagnosing and fixing invalidations. To demonstrate this tool, let's use it on our test methods defined above. For best results, you'll want to copy those method definitions into a file:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"f(::Real) = 1\ncallf(container) = f(container[1])\ncall2f(container) = callf(container)\n\nc64  = [1.0]; c32 = [1.0f0]; cabs = AbstractFloat[1.0];\ncall2f(c64)\ncall2f(c32)\ncall2f(cabs)\n\nusing SnoopCompileCore\ninvalidations = @snoopr f(::Float64) = 2\nusing SnoopCompile\ntrees = invalidation_trees(invalidations)\nmethod_invalidations = trees[1]","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"and include it into a fresh session.  (The full functionality of ascend doesn't work for methods defined at the REPL, but does if the methods are defined in a file.) In this demo, I called that file /tmp/snoopr.jl.","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"We start with","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"julia> root = method_invalidations.backedges[end]\nMethodInstance for f(::AbstractFloat) at depth 0 with 2 children","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"(It's common to start from the last element of backedges or mt_backedges since these have the largest number of children and are therefore most consequential.) Then:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"julia> ascend(root)\nChoose a call for analysis (q to quit):\n >   f(::AbstractFloat)\n       callf(::Vector{AbstractFloat})\n         call2f(::Vector{AbstractFloat})","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"This is an interactive menu: press the down arrow to go down, the up arrow to go up, and Enter to select an item for more detailed analysis. In large trees, you may also want to \"fold\" nodes of the tree (collapsing it so that the children are no longer displayed), particularly if you are working your way through a long series of invalidations and want to hide ones you've already dealt with. You toggle folding using the space bar, and folded nodes are printed with a + in front of them.","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"For example, if we press the down arrow once, we get","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"julia> ascend(root)\nChoose a call for analysis (q to quit):\n     f(::AbstractFloat)\n >     callf(::Vector{AbstractFloat})\n         call2f(::Vector{AbstractFloat})","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"Now hit Enter to select it:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"Choose caller of MethodInstance for f(::AbstractFloat) or proceed to typed code:\n > \"/tmp/snoopr.jl\", callf: lines [2]\n   Browse typed code","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"This is showing you another menu, with only two options (a third is to go back by hitting q). The first entry shows you the option to open the \"offending\" source file in callf at the position of the call to the parent node of callf, which in this case is f. (Sometimes there will be more than one call to the parent within the method, in which case instead of showing [1] it might show [1, 17, 39] indicating each separate location.) Selecting this option, when available, is typically the best way to start because you can sometimes resolve the problem just by inspection of the source.","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"If you hit the down arrow","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"Choose caller of MethodInstance for f(::AbstractFloat) or proceed to typed code:\n   \"/tmp/snoopr.jl\", callf: lines [2]\n > Browse typed code","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"and then hit Enter, this is what you see:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"│ ─ %-1  = invoke callf(::Vector{AbstractFloat})::Int64\nVariables\n  #self#::Core.Const(callf, false)\n  container::Vector{AbstractFloat}\n\nBody::Int64\n    @ /tmp/snoopr.jl:2 within `callf'\n1 ─ %1 = Base.getindex(container, 1)::AbstractFloat\n│   %2 = Main.f(%1)::Int64\n└──      return %2\n\nSelect a call to descend into or ↩ to ascend. [q]uit. [b]ookmark.\nToggles: [o]ptimize, [w]arn, [d]ebuginfo, [s]yntax highlight for Source/LLVM/Native.\nShow: [S]ource code, [A]ST, [L]LVM IR, [N]ative code\nAdvanced: dump [P]arams cache.\n\n • %1  = invoke getindex(::Vector{AbstractFloat},::Int64)::AbstractFloat\n   %2  = call #f(::AbstractFloat)::Int64\n   ↩","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"This is output from Cthulhu, and you should see its documentation for more information. (See also this video.) While it takes a bit of time to master Cthulhu, it is an exceptionally powerful tool for diagnosing and fixing inference issues.","category":"page"},{"location":"snoopr/#Tips-for-fixing-invalidations-1","page":"Snooping on and fixing invalidations: @snoopr","title":"Tips for fixing invalidations","text":"","category":"section"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"Invalidations occur in situations like our call2f(c64) example, where we changed our mind about what value f should return for Float64. Julia could not have returned the newly-correct answer without recompiling the call chain.","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"Aside from cases like these, most invalidations occur whenever new types are introduced, and some methods were previously compiled for abstract types. In some cases, this is inevitable, and the resulting invalidations simply need to be accepted as a consequence of a dynamic, updateable language. (As recommended above, you can often minimize invalidations by loading all your code at the beginning of your session, before triggering the compilation of more methods.) However, in many circumstances an invalidation indicates an opportunity to improve code. In our first example, note that the call call2f(c32) did not get invalidated: this is because the compiler knew all the specific types, and new methods did not affect any of those types. The main tips for writing invalidation-resistant code are:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"use concrete types wherever possible\nwrite inferrable code (be especially aware of julia issue 15276)\ndon't engage in type-piracy (our c64 example is essentially like type-piracy, where we redefined behavior for a pre-existing type)","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"Since these tips also improve performance and allow programs to behave more predictably, these guidelines are not intrusive. Indeed, searching for and eliminating invalidations can help you improve the quality of your code.","category":"page"},{"location":"snoopr/#Adding-type-annotations-1","page":"Snooping on and fixing invalidations: @snoopr","title":"Adding type annotations","text":"","category":"section"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"In cases where invalidations occur, but you can't use concrete types (there are indeed many valid uses of Vector{Any}), you can often prevent the invalidation using some additional knowledge. One common example is extracting information from an IOContext structure, which is roughly defined as","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"struct IOContext{IO_t <: IO} <: AbstractPipe\n    io::IO_t\n    dict::ImmutableDict{Symbol, Any}\nend","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"There are good reasons to use a value-type of Any, but that makes it impossible for the compiler to infer the type of any object looked up in an IOContext. Fortunately, you can help! For example, the documentation specifies that the :color setting should be a Bool, and since it appears in documentation it's something we can safely enforce. Changing","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"iscolor = get(io, :color, false)","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"to","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"iscolor = get(io, :color, false)::Bool     # assert that the rhs is Bool-valued","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"suffices to ensure that the compiler can count on iscolor being a Bool.","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"As a more detailed example, suppose you're writing code that parses Julia's Expr type:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"julia> ex = :(Array{Float32,3})\n:(Array{Float32, 3})\n\njulia> dump(ex)\nExpr\n  head: Symbol curly\n  args: Vector{Any(3,))\n    1: Symbol Array\n    2: Symbol Float32\n    3: Int64 3","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"ex.args is a Vector{Any}. However, for a :curly expression only certain types will be found among the arguments; you could write key portions of your code as","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"a = ex.args[2]\nif a isa Symbol\n    # inside this block, Julia knows `a` is a Symbol, and so methods called on `a` will be resistant to invalidation\n    foo(a)\nelseif a isa Expr && length((a::Expr).args) > 2\n    a::Expr         # sometimes you have to help inference by adding a type-assert\n    x = bar(a)      # `bar` is now resistant to invalidation\nelseif a isa Integer\n    # even though you've not made this fully-inferrable, you've at least reduced the scope for invalidations\n    # by limiting the subset of `foobar` methods that might be called\n    y = foobar(a)\nend","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"Other tricks include replacing broadcasting on v::Vector{Any} with Base.mapany(f, v)–mapany avoids trying to narrow the type of f(v[i]) and just assumes it will be Any, thereby avoiding invalidations of many convert methods.","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"Adding type-assertions and fixing inference problems are the most common approaches for fixing invalidations. You can discover these manually, but using Cthulhu is highly recommended.","category":"page"},{"location":"snoopr/#Handling-edge-cases-1","page":"Snooping on and fixing invalidations: @snoopr","title":"Handling edge cases","text":"","category":"section"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"You can sometimes get invalidations from failing to handle \"formal\" possibilities. For example, operations with regular expressions might return a Union{Nothing, RegexMatch}. You can sometimes get poor type inference by writing code that fails to take account of the possibility that nothing might be returned. For example, a comprehension","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"ms = [m.match for m in match.((rex,), my_strings)]","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"might be replaced with","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"ms = [m.match for m in match.((rex,), my_strings) if m !== nothing]","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"and return a better-typed result.","category":"page"}]
}
