<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Using @snoopi_deep results to generate precompile directives · SnoopCompile</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">SnoopCompile</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">SnoopCompile.jl</a></li><li><a class="tocitem" href="../tutorial/">Tutorial on the foundations</a></li><li><span class="tocitem">Modern tools</span><ul><li><a class="tocitem" href="../snoopr/">Snooping on and fixing invalidations: <code>@snoopr</code></a></li><li><a class="tocitem" href="../snoopi_deep/">Snooping on inference: <code>@snoopi_deep</code></a></li><li><a class="tocitem" href="../snoopi_deep_analysis/">Using <code>@snoopi_deep</code> results to improve inferrability and control specialization</a></li><li class="is-active"><a class="tocitem" href>Using <code>@snoopi_deep</code> results to generate precompile directives</a><ul class="internal"><li><a class="tocitem" href="#Parcel-1"><span>Parcel</span></a></li><li><a class="tocitem" href="#SnoopCompile.write-1"><span>SnoopCompile.write</span></a></li><li><a class="tocitem" href="#Final-results-1"><span>Final results</span></a></li><li><a class="tocitem" href="#Summary-1"><span>Summary</span></a></li></ul></li></ul></li><li><span class="tocitem">Older tools</span><ul><li><a class="tocitem" href="../snoopi/">Snooping on inference: <code>@snoopi</code></a></li><li><a class="tocitem" href="../snoopc/">Snooping on code generation: <code>@snoopc</code></a></li></ul></li><li><a class="tocitem" href="../userimg/">Creating <code>userimg.jl</code> files</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modern tools</a></li><li class="is-active"><a href>Using <code>@snoopi_deep</code> results to generate precompile directives</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Using <code>@snoopi_deep</code> results to generate precompile directives</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/timholy/SnoopCompile.jl/blob/master/docs/src/snoopi_deep_parcel.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Using-@snoopi_deep-results-to-generate-precompile-directives-1"><a class="docs-heading-anchor" href="#Using-@snoopi_deep-results-to-generate-precompile-directives-1">Using <code>@snoopi_deep</code> results to generate precompile directives</a><a class="docs-heading-anchor-permalink" href="#Using-@snoopi_deep-results-to-generate-precompile-directives-1" title="Permalink"></a></h1><p>Improving inferrability, specialization, and precompilability may sometimes feel like &quot;eating your vegetables&quot;: really good for you, but it sometimes feels like work.  (Depending on tastes; I love vegetables.) While we&#39;ve already gotten some payoff, now we&#39;re going to collect an additional reward for our hard work: the &quot;dessert&quot; of adding <code>precompile</code> directives. It&#39;s worth emphasing that if we hadn&#39;t done the analysis of inference triggers and made improvements to our package, the benefit of adding <code>precompile</code> directives would have been substantially smaller.</p><h2 id="Parcel-1"><a class="docs-heading-anchor" href="#Parcel-1">Parcel</a><a class="docs-heading-anchor-permalink" href="#Parcel-1" title="Permalink"></a></h2><p><code>precompile</code> directives have to be emitted by the module that owns the method. SnoopCompile comes with a tool, <code>parcel</code>, that splits out the &quot;root-most&quot; precompilable MethodInstances into their constituent modules. In our case, since we&#39;ve made almost every call precompilable, this will typically correspond to the bottom row of boxes in the flame graph. In cases where you have some non-precompilable MethodInstances, they will include MethodInstances from higher up in the call tree.</p><p>Let&#39;s use <code>SnoopCompile.parcel</code> on <code>OptimizeMeFixed</code>:</p><pre><code class="language-julia">julia&gt; ttot, pcs = SnoopCompile.parcel(tinf);

julia&gt; ttot
0.80544499

julia&gt; pcs
4-element Vector{Pair{Module, Tuple{Float64, Vector{Tuple{Float64, Core.MethodInstance}}}}}:
                 Core =&gt; (0.00010728, [(0.00010728, MethodInstance for (NamedTuple{(:sizehint,), T} where T&lt;:Tuple)(::Tuple{Int64}))])
                 Base =&gt; (0.023301831000000002, [(2.577e-5, MethodInstance for getproperty(::IOBuffer, ::Symbol)), (3.9483e-5, MethodInstance for ==(::Type, ::Nothing)), (5.104e-5, MethodInstance for typeinfo_eltype(::Type)), (0.000325206, MethodInstance for show(::IOContext{IOBuffer}, ::Any)), (0.000351546, MethodInstance for IOContext(::IOBuffer, ::IOContext{Base.TTY})), (0.000409676, MethodInstance for Pair{Symbol, DataType}(::Any, ::Any)), (0.000651708, MethodInstance for print(::IOContext{Base.TTY}, ::String, ::String, ::Vararg{String, N} where N)), (0.001187032, MethodInstance for Pair(::Symbol, ::Type)), (0.0015947350000000001, MethodInstance for show(::IOContext{IOBuffer}, ::UInt16)), (0.008491582000000001, MethodInstance for show(::IOContext{IOBuffer}, ::Tuple{String, Int64})), (0.010174053, MethodInstance for show(::IOContext{IOBuffer}, ::Vector{Int64}))])
             Base.Ryu =&gt; (0.12526549099999998, [(0.03687417999999999, MethodInstance for writeshortest(::Vector{UInt8}, ::Int64, ::Float32, ::Bool, ::Bool, ::Bool, ::Int64, ::UInt8, ::Bool, ::UInt8, ::Bool, ::Bool)), (0.08839131099999999, MethodInstance for show(::IOContext{IOBuffer}, ::Float32))])
 Main.OptimizeMeFixed =&gt; (0.6468779330000002, [(0.10149027000000001, MethodInstance for show(::IOContext{Base.TTY}, ::MIME{Symbol(&quot;text/plain&quot;)}, ::Vector{Main.OptimizeMeFixed.Object})), (0.14666734500000003, MethodInstance for show(::IOContext{Base.TTY}, ::MIME{Symbol(&quot;text/plain&quot;)}, ::Vector{Main.OptimizeMeFixed.Container{Any}})), (0.39872031800000013, MethodInstance for main())])</code></pre><p>This tells us that a total of 0.8s were spent on inference. <code>parcel</code> discovered precompilable MethodInstances for four modules, <code>Core</code>, <code>Base</code>, <code>Base.Ryu</code>, and <code>OptimizeMeFixed</code>. These are listed in increasing order of inference time.</p><p>Let&#39;s look specifically at <code>OptimizeMeFixed</code>, since that&#39;s under our control:</p><pre><code class="language-julia">julia&gt; pcmod = pcs[end]
Main.OptimizeMeFixed =&gt; (0.6468779330000002, Tuple{Float64, Core.MethodInstance}[(0.10149027000000001, MethodInstance for show(::IOContext{Base.TTY}, ::MIME{Symbol(&quot;text/plain&quot;)}, ::Vector{Main.OptimizeMeFixed.Object})), (0.14666734500000003, MethodInstance for show(::IOContext{Base.TTY}, ::MIME{Symbol(&quot;text/plain&quot;)}, ::Vector{Main.OptimizeMeFixed.Container{Any}})), (0.39872031800000013, MethodInstance for main())])

julia&gt; tmod, tpcs = pcmod.second;

julia&gt; tmod
0.6468779330000002

julia&gt; tpcs
3-element Vector{Tuple{Float64, Core.MethodInstance}}:
 (0.10149027000000001, MethodInstance for show(::IOContext{Base.TTY}, ::MIME{Symbol(&quot;text/plain&quot;)}, ::Vector{Main.OptimizeMeFixed.Object}))
 (0.14666734500000003, MethodInstance for show(::IOContext{Base.TTY}, ::MIME{Symbol(&quot;text/plain&quot;)}, ::Vector{Main.OptimizeMeFixed.Container{Any}}))
 (0.39872031800000013, MethodInstance for main())</code></pre><p>0.65s of that time is due to <code>OptimizeMeFixed</code>, and <code>parcel</code> discovered three MethodInstances to precompile. <code>main()</code> is the most costly at nearly 0.4s.</p><p>We could look at the others similarly.</p><h2 id="SnoopCompile.write-1"><a class="docs-heading-anchor" href="#SnoopCompile.write-1">SnoopCompile.write</a><a class="docs-heading-anchor-permalink" href="#SnoopCompile.write-1" title="Permalink"></a></h2><p>You can generate files that contain ready-to-use <code>precompile</code> directives using <code>SnoopCompile.write</code>:</p><pre><code class="language-julia">julia&gt; SnoopCompile.write(&quot;/tmp/precompiles_OptimizeMe&quot;, pcs)
Core: no precompile statements out of 0.00010728
Base: precompiled 0.021447402 out of 0.023301831000000002
Base.Ryu: precompiled 0.12526549099999998 out of 0.12526549099999998
Main.OptimizeMeFixed: precompiled 0.6468779330000002 out of 0.6468779330000002</code></pre><p>You&#39;ll now find a directory <code>/tmp/precompiles_OptimizeMe</code>, and inside you&#39;ll find three files, for <code>Base</code>, <code>Base.Ryu</code>, and <code>OptimizeMeFixed</code>, respectively. The contents of the last of these should be recognizable:</p><pre><code class="language-julia">function _precompile_()
    ccall(:jl_generating_output, Cint, ()) == 1 || return nothing
    Base.precompile(Tuple{typeof(main)})   # time: 0.39872032
    Base.precompile(Tuple{typeof(show),IOContext{Base.TTY},MIME{Symbol(&quot;text/plain&quot;)},Vector{Container{Any}}})   # time: 0.14666735
    Base.precompile(Tuple{typeof(show),IOContext{Base.TTY},MIME{Symbol(&quot;text/plain&quot;)},Vector{Object}})   # time: 0.10149027
end</code></pre><p>The first <code>ccall</code> line ensures we only pay the cost of running these <code>precompile</code> directives if we&#39;re building the package; this is relevant mostly if you&#39;re running Julia with <code>--compiled-modules=no</code> so it is rarely something that matters. (It would also matter if you&#39;ve set <code>__precompile__(false)</code> at the top of your module, but if so why are you reading this?)</p><p>This file is ready to be moved into the <code>OptimizeMe</code> repository and <code>include</code>d into your module definition. In general it&#39;s recommended to do this inside a block</p><pre><code class="language-julia">if Base.VERSION &gt;= v&quot;1.4.2&quot;
    include(&quot;precompile.jl&quot;)
    _precompile_()
end</code></pre><p>because earlier versions of Julia occasionally crashed on certain precompile directives. It&#39;s also perfectly fine to use</p><pre><code class="language-julia">if Base.VERSION &gt;= v&quot;1.4.2&quot;
    Base.precompile(Tuple{typeof(main)})   # time: 0.39872032
    Base.precompile(Tuple{typeof(show),IOContext{Base.TTY},MIME{Symbol(&quot;text/plain&quot;)},Vector{Container{Any}}})   # time: 0.14666735
    Base.precompile(Tuple{typeof(show),IOContext{Base.TTY},MIME{Symbol(&quot;text/plain&quot;)},Vector{Object}})   # time: 0.10149027
end</code></pre><p>directly in the <code>OptimizeMeFixed</code> module, usually as the last block of the module definition.</p><p>You might also consider submitting some of the other files (or their <code>precompile</code> directives) to the packages you depend on. In some cases, the specific argument type combinations may be too &quot;niche&quot; to be worth specializing; one such case is found here, a <code>show</code> method for <code>Tuple{String, Int64}</code>. But in other cases, these may be very worthy additions to the package.</p><h2 id="Final-results-1"><a class="docs-heading-anchor" href="#Final-results-1">Final results</a><a class="docs-heading-anchor-permalink" href="#Final-results-1" title="Permalink"></a></h2><p>Let&#39;s check out the final results of adding these <code>precompile</code> directives to <code>OptimizeMeFixed</code>. First, let&#39;s build both modules as precompiled packages:</p><pre><code class="language-julia">ulia&gt; push!(LOAD_PATH, &quot;.&quot;)
4-element Vector{String}:
 &quot;@&quot;
 &quot;@v#.#&quot;
 &quot;@stdlib&quot;
 &quot;.&quot;

julia&gt; using OptimizeMe
[ Info: Precompiling OptimizeMe [top-level]

julia&gt; using OptimizeMeFixed
[ Info: Precompiling OptimizeMeFixed [top-level]</code></pre><p>Now in fresh sessions,</p><pre><code class="language-julia">julia&gt; @time (using OptimizeMe; OptimizeMe.main())
3.14 is great
2.718 is jealous
⋮
Object x: 7
  3.091609 seconds (10.62 M allocations: 581.374 MiB, 5.21% gc time, 99.67% compilation time)</code></pre><p>versus</p><pre><code class="language-julia">julia&gt; @time (using OptimizeMeFixed; OptimizeMeFixed.main())
3.14 is great
2.718 is jealous
⋮
 Object x: 7
  1.806477 seconds (5.37 M allocations: 288.433 MiB, 5.10% gc time, 96.86% compilation time)</code></pre><p>We&#39;ve cut down on the latency by nearly a factor of two. Moreover, if Julia someday caches generated code, we&#39;re well-prepared to capitalize on the benefits, because the same improvements in &quot;code ownership&quot; are almost certain to pay dividends there too.</p><p>If you inspect the results, you may suffer a few disappointments: some methods that we expected to precompile, particularly from our &quot;soft&quot; piracy <code>show</code> tricks, don&#39;t &quot;take.&quot; At the moment there appears to be a small subset of methods that fail to precompile, and the reasons are not yet widely understood. At present, the best advice seems to be to comment-out any precompile directives that don&#39;t &quot;take,&quot; since otherwise they increase the build time for the package without material benefit. These failures may be addressed in future versions of Julia. It&#39;s also worth appreciating how much we have succeeded in reducing latency, with the awareness that we may be able to get even greater benefit in the future.</p><h2 id="Summary-1"><a class="docs-heading-anchor" href="#Summary-1">Summary</a><a class="docs-heading-anchor-permalink" href="#Summary-1" title="Permalink"></a></h2><p><code>@snoopi_deep</code> collects enough data to learn which methods are triggering inference, how heavily methods are being specialized, and so on. Examining your code from the standpoint of inference and specialization may be unfamiliar at first, but like other aspects of package development (testing, documentation, and release compatibility management) it can lead to significant improvements in the quality-of-life for you and your users. By optimizing your packages and then adding <code>precompile</code> directives, you can often cut down substantially on latency.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../snoopi_deep_analysis/">« Using <code>@snoopi_deep</code> results to improve inferrability and control specialization</a><a class="docs-footer-nextpage" href="../snoopi/">Snooping on inference: <code>@snoopi</code> »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 4 January 2021 15:46">Monday 4 January 2021</span>. Using Julia version 1.7.0-DEV.206.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
