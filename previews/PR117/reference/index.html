<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · SnoopCompile</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">SnoopCompile</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">SnoopCompile.jl</a></li><li><a class="tocitem" href="../snoopi/">Snooping on inference: <code>@snoopi</code></a></li><li><a class="tocitem" href="../snoopc/">Snooping on code generation: <code>@snoopc</code></a></li><li><a class="tocitem" href="../userimg/">Creating <code>userimg.jl</code> files</a></li><li><a class="tocitem" href="../bot/">SnoopCompile Bot</a></li><li><a class="tocitem" href="../snoopr/">Snooping on and fixing invalidations: <code>@snoopr</code></a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Interactive-features-1"><span>Interactive features</span></a></li><li><a class="tocitem" href="#Snoop-bot-1"><span>Snoop bot</span></a></li><li><a class="tocitem" href="#Snoop-bot-utilities-1"><span>Snoop bot utilities</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/timholy/SnoopCompile.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference-1"><a class="docs-heading-anchor" href="#Reference-1">Reference</a><a class="docs-heading-anchor-permalink" href="#Reference-1" title="Permalink"></a></h1><h2 id="Interactive-features-1"><a class="docs-heading-anchor" href="#Interactive-features-1">Interactive features</a><a class="docs-heading-anchor-permalink" href="#Interactive-features-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SnoopCompileCore.@snoopi" href="#SnoopCompileCore.@snoopi"><code>SnoopCompileCore.@snoopi</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">inf_timing = @snoopi commands
inf_timing = @snoopi tmin=0.0 commands</code></pre><p>Execute <code>commands</code> while snooping on inference. Returns an array of <code>(t, linfo)</code> tuples, where <code>t</code> is the amount of time spent infering <code>linfo</code> (a <code>MethodInstance</code>).</p><p>Methods that take less time than <code>tmin</code> will not be reported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/55863ae5561dfb91723633579968ce98d0415092/SnoopCompileCore/src/snoopi.jl#L49-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompileCore.@snoopc" href="#SnoopCompileCore.@snoopc"><code>SnoopCompileCore.@snoopc</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@snoopc &quot;compiledata.csv&quot; begin
    # Commands to execute, in a new process
end</code></pre><p>causes the julia compiler to log all functions compiled in the course of executing the commands to the file &quot;compiledata.csv&quot;. This file can be used for the input to <code>SnoopCompile.read</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/55863ae5561dfb91723633579968ce98d0415092/SnoopCompileCore/src/snoopc.jl#L5-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompileCore.@snoopr" href="#SnoopCompileCore.@snoopr"><code>SnoopCompileCore.@snoopr</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">list = @snoopr expr</code></pre><p>Capture method cache invalidations triggered by evaluating <code>expr</code>. <code>list</code> is a sequence of invalidated <code>Core.MethodInstance</code>s together with &quot;explanations,&quot; consisting of integers (encoding depth) and strings (documenting the source of an invalidation).</p><p>Unless you are working at a low level, you essentially always want to pass <code>list</code> directly to <a href="@ref"><code>SnoopCompileAnalysis.invalidation_trees</code></a>.</p><p><strong>Extended help</strong></p><p><code>list</code> is in a format where the &quot;reason&quot; comes after the items. Method deletion results in the sequence</p><pre><code class="language-none">[zero or more (mi, &quot;invalidate_mt_cache&quot;) pairs..., zero or more (depth1 tree, loctag) pairs..., method, loctag] with loctag = &quot;jl_method_table_disable&quot;</code></pre><p>where <code>mi</code> means a <code>MethodInstance</code>. <code>depth1</code> means a sequence starting at <code>depth=1</code>.</p><p>Method insertion results in the sequence</p><pre><code class="language-none">[zero or more (depth0 tree, sig) pairs..., same info as with delete_method except loctag = &quot;jl_method_table_insert&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/55863ae5561dfb91723633579968ce98d0415092/SnoopCompileCore/src/snoopr.jl#L3-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompileAnalysis.parcel" href="#SnoopCompileAnalysis.parcel"><code>SnoopCompileAnalysis.parcel</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>pc = parcel(calls; subst=[], exclusions=[])</code> assigns each compile statement to the module that owns the function. Perform string substitution via <code>subst=[&quot;Module1&quot;=&gt;&quot;Module2&quot;]</code>, and omit functions in particular modules with <code>exclusions=[&quot;Module3&quot;]</code>. On output, <code>pc[:Module2]</code> contains all the precompiles assigned to <code>Module2</code>.</p><p>Use <code>SnoopCompile.write(prefix, pc)</code> to generate a series of files in directory <code>prefix</code>, one file per module.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/55863ae5561dfb91723633579968ce98d0415092/SnoopCompileAnalysis/src/parcel_snoopc.jl#L116-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompileAnalysis.write" href="#SnoopCompileAnalysis.write"><code>SnoopCompileAnalysis.write</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">write(prefix::AbstractString, pc::Dict; always::Bool = false)</code></pre><p>Write each modules&#39; precompiles to a separate file.  If <code>always</code> is true, the generated function will always run the precompile statements when called, otherwise the statements will only be called during package precompilation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/55863ae5561dfb91723633579968ce98d0415092/SnoopCompileAnalysis/src/write.jl#L19-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompileAnalysis.read" href="#SnoopCompileAnalysis.read"><code>SnoopCompileAnalysis.read</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>SnoopCompile.read(&quot;compiledata.csv&quot;)</code> reads the log file produced by the compiler and returns the functions as a pair of arrays. The first array is the amount of time required to compile each function, the second is the corresponding function + types. The functions are sorted in order of increasing compilation time. (The time does not include the cost of nested compiles.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/55863ae5561dfb91723633579968ce98d0415092/SnoopCompileAnalysis/src/parcel_snoopc.jl#L8-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompileAnalysis.format_userimg" href="#SnoopCompileAnalysis.format_userimg"><code>SnoopCompileAnalysis.format_userimg</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>pc = format_userimg(calls; subst=[], exclusions=[])</code> generates precompile directives intended for your base/userimg.jl script. Use <code>SnoopCompile.write(filename, pc)</code> to create a file that you can <code>include</code> into <code>userimg.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/55863ae5561dfb91723633579968ce98d0415092/SnoopCompileAnalysis/src/parcel_snoopc.jl#L168-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompileBot.timesum" href="#SnoopCompileBot.timesum"><code>SnoopCompileBot.timesum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">timesum(snoop::Vector{Tuple{Float64, Core.MethodInstance}}, unit = :s)</code></pre><p>Calculates the total time measured by a snoop macro. <code>unit</code> can be :s or :ms.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using SnoopCompile
data = @snoopi begin
    using MatLang
    MatLang_rootpath = dirname(dirname(pathof(&quot;MatLang&quot;)))

    include(&quot;$MatLang_rootpath/test/runtests.jl&quot;)
end
println(timesum(data, :ms))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/55863ae5561dfb91723633579968ce98d0415092/SnoopCompileBot/src/botutils.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompileAnalysis.invalidation_trees" href="#SnoopCompileAnalysis.invalidation_trees"><code>SnoopCompileAnalysis.invalidation_trees</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">trees = invalidation_trees(list)</code></pre><p>Parse <code>list</code>, as captured by <a href="@ref"><code>SnoopCompileCore.@snoopr</code></a>, into a set of invalidation trees, where parents nodes were called by their children.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; f(x::Int)  = 1
f (generic function with 1 method)

julia&gt; f(x::Bool) = 2
f (generic function with 2 methods)

julia&gt; applyf(container) = f(container[1])
applyf (generic function with 1 method)

julia&gt; callapplyf(container) = applyf(container)
callapplyf (generic function with 1 method)

julia&gt; c = Any[1]
1-element Array{Any,1}:
 1

julia&gt; callapplyf(c)
1

julia&gt; trees = invalidation_trees(@snoopr f(::AbstractFloat) = 3)
1-element Array{SnoopCompile.MethodInvalidations,1}:
 inserting f(::AbstractFloat) in Main at REPL[36]:1 invalidated:
   mt_backedges: 1: signature Tuple{typeof(f),Any} triggered MethodInstance for applyf(::Array{Any,1}) (1 children) more specific</code></pre><p>See the documentation for further details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/55863ae5561dfb91723633579968ce98d0415092/SnoopCompileAnalysis/src/invalidations.jl#L210-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompileAnalysis.filtermod" href="#SnoopCompileAnalysis.filtermod"><code>SnoopCompileAnalysis.filtermod</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">thinned = filtermod(module, trees::AbstractVector{MethodInvalidations})</code></pre><p>Select just the cases of invalidating a method defined in <code>module</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/55863ae5561dfb91723633579968ce98d0415092/SnoopCompileAnalysis/src/invalidations.jl#L329-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompileAnalysis.findcaller" href="#SnoopCompileAnalysis.findcaller"><code>SnoopCompileAnalysis.findcaller</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">methinvs = findcaller(method::Method, trees)</code></pre><p>Find a path through <code>trees</code> that reaches <code>method</code>. Returns a single <code>MethodInvalidations</code> object.</p><p><strong>Examples</strong></p><p>Suppose you know that loading package <code>SomePkg</code> triggers invalidation of <code>f(data)</code>. You can find the specific source of invalidation as follows:</p><pre><code class="language-none">f(data)                             # run once to force compilation
m = @which f(data)
using SnoopCompile
trees = invalidation_trees(@snoopr using SomePkg)
methinvs = findcaller(m, trees)</code></pre><p>If you don&#39;t know which method to look for, but know some operation that has had added latency, you can look for methods using <code>@snoopi</code>. For example, suppose that loading <code>SomePkg</code> makes the next <code>using</code> statement slow. You can find the source of trouble with</p><pre><code class="language-none">julia&gt; using SnoopCompile

julia&gt; trees = invalidation_trees(@snoopr using SomePkg);

julia&gt; tinf = @snoopi using SomePkg            # this second `using` will need to recompile code invalidated above
1-element Array{Tuple{Float64,Core.MethodInstance},1}:
 (0.08518409729003906, MethodInstance for require(::Module, ::Symbol))

julia&gt; m = tinf[1][2].def
require(into::Module, mod::Symbol) in Base at loading.jl:887

julia&gt; findcaller(m, trees)
inserting ==(x, y::SomeType) in SomeOtherPkg at /path/to/code:100 invalidated:
   backedges: 1: superseding ==(x, y) in Base at operators.jl:83 with MethodInstance for ==(::Symbol, ::Any) (16 children) more specific</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/55863ae5561dfb91723633579968ce98d0415092/SnoopCompileAnalysis/src/invalidations.jl#L352-L390">source</a></section></article><h2 id="Snoop-bot-1"><a class="docs-heading-anchor" href="#Snoop-bot-1">Snoop bot</a><a class="docs-heading-anchor-permalink" href="#Snoop-bot-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SnoopCompileBot.BotConfig" href="#SnoopCompileBot.BotConfig"><code>SnoopCompileBot.BotConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BotConfig(package_name::AbstractString ; exclusions, os, else_os, version, else_version, package_path, precompiles_rootpath, subst, tmin)</code></pre><p>Construct a SnoopCompile bot configuration. <code>package_name</code> is the name of the package. This object is passed to <a href="#SnoopCompileBot.snoop_bot"><code>snoop_bot</code></a> and <a href="#SnoopCompileBot.snoop_bench"><code>snoop_bench</code></a>.</p><p>You may supply the following optional <strong>keyword</strong> arguments:</p><ul><li><p><code>exclusions</code> : A vector of of Strings (or RegExp) to exclude some functions from being precompiled</p></li><li><p><code>os</code>: A vector of of Strings (or RegExp) to support with precompile statements.</p></li></ul><p>Example: <code>os = [&quot;windows&quot;, &quot;linux&quot;]</code></p><ul><li><code>else_os</code>: If you want to use a specific operating system&#39;s precompile file as the default, set <code>else_os</code> to the name of that os. Not passing this argument skips precompilation on any operating system other than those explicitly listed in <code>os</code>.</li></ul><p>Example: <code>else_os = &quot;linux&quot;</code></p><ul><li><code>version</code>: A vector of of Julia versions used to generate precompile signatures.</li></ul><p>Example: <code>version = [v&quot;1.1&quot;, v&quot;1.4.2&quot;, &quot;nightly&quot;]</code></p><p>It is assumed that the generated precompile signatures are valid for patch versions of Julia (e.g. giving v&quot;1.4.2&quot; supports v&quot;1.4.0&quot; to v&quot;1.4.9&quot;).</p><ul><li><code>else_version</code>: the Julia version used to generate the default signatures for other <code>version</code>s.</li></ul><p>Not passing this argument skips precompilation on any Julia version other than those explicitly listed in <code>version</code>.</p><p>Example: <code>else_version = v&quot;1.4.2&quot;</code></p><ul><li><code>yml_path</code>: instead of directly passing <code>os</code> and <code>version</code> to BotConfig, you can pass <code>yml_path</code> which should be the GitHub actions YAML path or file name.</li></ul><p>It assumes that the job name is <code>SnoopCompile</code>.</p><p>Example: <code>yaml_path = &quot;SnoopCompile.yml&quot;</code></p><ul><li><p><code>package_path</code>: path to the main <code>.jl</code> file of the package (similar to <code>pathof</code>). Default path is <code>pathof_noload(package_name)</code>.</p></li><li><p><code>precompiles_rootpath</code>: the path where precompile files are stored. Default path is &quot;dirname(dirname(package_path))/deps/SnoopCompile/precompile&quot;.</p></li><li><p><code>subst</code> : A vector of pairs of Strings (or RegExp) to replace a packages precompile statements with another&#39;s package like <code>[&quot;ImageTest&quot; =&gt; &quot;Images&quot;]</code>.</p></li><li><p><code>tmin</code>: Methods that take less time than <code>tmin</code> to be inferred will not be added to the precompile statements. Defaults to 0.</p></li><li><p><code>check_eval</code>: By default, the bot discards the precompile statements that cannot be <code>eval</code>ed.</p></li></ul><p>In rare cases (when snooping is very time consuming), you may want to do this manually by using the printed errors to add the problematic functions to <code>exclusions</code> and then set <code>check_eval=false</code> for the future runs.</p><p><strong>Example</strong></p><pre><code class="language-julia">botconfig1 = BotConfig(
  &quot;Zygote&quot;;                            # package name (the one this configuration lives in)
  os = [&quot;linux&quot;, &quot;windows&quot;, &quot;macos&quot;],  # operating systems for which to precompile
  version = [v&quot;1.4.2&quot;, v&quot;1.3.1&quot;],      # supported Julia versions
  exclusions = [&quot;SqEuclidean&quot;],         # exclude functions (by name) that would be problematic if precompiled
)

botconfig2 = BotConfig(
  &quot;Zygote&quot;;                            # package name (the one this configuration lives in)
  yml_path = &quot;SnoopCompile.yml&quot;        # parse `os` and `version` from `SnoopCompile.yml`
  exclusions = [&quot;SqEuclidean&quot;],         # exclude functions (by name) that would be problematic if precompiled
)

# A full example:
BotConfig(&quot;MatLang&quot;, exclusions = [&quot;badfunction&quot;], os = [&quot;linux&quot;, &quot;windows&quot;, &quot;macos&quot;], else_os = &quot;linux&quot;, version = [&quot;1.4.2&quot;, &quot;1.2&quot;, &quot;1.0.5&quot;], else_version = &quot;1.4.2&quot; )

# Different examples for other possibilities:
BotConfig(&quot;MatLang&quot;)

BotConfig(&quot;MatLang&quot;, exclusions = [&quot;badfunction&quot;])

BotConfig(&quot;MatLang&quot;, os = [&quot;linux&quot;, &quot;windows&quot;])

BotConfig(&quot;MatLang&quot;, os = [&quot;windows&quot;, &quot;linux&quot;], else_os = &quot;linux&quot;)

BotConfig(&quot;MatLang&quot;, version = [v&quot;1.1&quot;, v&quot;1.4.2&quot;])

BotConfig(&quot;MatLang&quot;, version = [v&quot;1.1&quot;, v&quot;1.4.2&quot;], else_version = v&quot;1.4.2&quot;)

BotConfig(&quot;MatLang&quot;, os = [&quot;linux&quot;, &quot;windows&quot;], version = [v&quot;1.1&quot;, v&quot;1.4.2&quot;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/55863ae5561dfb91723633579968ce98d0415092/SnoopCompileBot/src/SnoopCompileBot.jl#L20-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompileBot.snoop_bot" href="#SnoopCompileBot.snoop_bot"><code>SnoopCompileBot.snoop_bot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">snoop_bot(config::BotConfig, path_to_example_script::String, test_modul=Main; snoop_mode=:auto)</code></pre><p>Generate precompile statements using a precompile script. <code>config</code> can be generated by <a href="#SnoopCompileBot.BotConfig"><code>BotConfig</code></a>. <code>path_to_example_script</code> is preferred to be an absolute path. The example script will be run in the module specified by <code>test_modul</code>. <code>snoop_mode</code> can be <code>:auto</code>, <code>:snoopi</code> (to run <a href="@ref"><code>SnoopCompileCore.@snoopi</code></a>), or <code>:snoopc</code> (to run <a href="@ref"><code>SnoopCompileCore.@snoopc</code></a>), where <code>:auto</code> chooses <code>:snoopi</code> on supported versions of Julia.</p><p>See the <a href="https://timholy.github.io/SnoopCompile.jl/stable/bot/">online documentation</a> for a more complete overview.</p><p><strong>Extended help</strong></p><p><strong>Example</strong></p><p>In this case, the bot-running script is placed in the same directory as the precompile script, so we can use <code>@__DIR__</code> to find it:</p><pre><code class="language-julia">using SnoopCompile

snoop_bot(BotConfig(&quot;MatLang&quot;), &quot;$(@__DIR__)/example_script.jl&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/55863ae5561dfb91723633579968ce98d0415092/SnoopCompileBot/src/snoop_bot.jl#L146-L172">source</a></section><section><div><pre><code class="language-none">snoop_bot(config::BotConfig, test_modul::Module = Main)</code></pre><p>Generate precompile statements using the package&#39;s <code>runtests.jl</code> file.</p><p>During snooping, <code>snoop_bot</code> sets the global variable <code>SnoopCompile_ENV</code> to <code>true</code>. If needed, your <code>runtests.jl</code> can check for the existence and value of this variable to customize test behavior specifically for snooping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/55863ae5561dfb91723633579968ce98d0415092/SnoopCompileBot/src/snoop_bot.jl#L184-L192">source</a></section><section><div><pre><code class="language-none">snoop_bot(config::BotConfig, expression::Expr, test_modul::Module = Main)</code></pre><p>Generate precompile statements by evaluating an expression, for example <code>:(using MyPackage)</code>. Interpolation and macros are not supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/55863ae5561dfb91723633579968ce98d0415092/SnoopCompileBot/src/snoop_bot.jl#L200-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompileBot.snoop_bench" href="#SnoopCompileBot.snoop_bench"><code>SnoopCompileBot.snoop_bench</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">snoop_bench(config::BotConfig, path_to_example_script::String, test_modul::Module=Main; snoop_mode=:auto)</code></pre><p>Benchmark the impact of precompile statements, by running a script with and without the precompiles. <code>config</code> can be generated by <a href="#SnoopCompileBot.BotConfig"><code>BotConfig</code></a>. <code>path_to_example_script</code> is preferred to be an absolute path. The example script will be run in the module specified by <code>test_modul</code>. <code>snoop_mode</code> can be <code>:auto</code>, <code>:snoopi</code> (to test with <a href="@ref"><code>SnoopCompileCore.@snoopi</code></a>), or <code>:runtime</code> (to measure total script run time with <code>@timev</code>). <code>:auto</code> chooses <code>:snoopi</code> on supported versions of Julia.</p><p>See the <a href="https://timholy.github.io/SnoopCompile.jl/stable/bot/">online documentation</a> for a more complete overview.</p><p><strong>Extended help</strong></p><p><strong>Example</strong></p><p>In this case, the benchmarking script is placed in the same directory as the precompile script, so we can use <code>@__DIR__</code> to find it:</p><pre><code class="language-julia">using SnoopCompile

snoop_bench(BotConfig(&quot;MatLang&quot;), &quot;$(@__DIR__)/example_script.jl&quot;)</code></pre><p>As an alternative to <code>@__DIR__</code> (for example, if you store your benchmarking script(s) outside the package itself), you can find the package with <a href="#SnoopCompileBot.pathof_noload"><code>pathof_noload</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/55863ae5561dfb91723633579968ce98d0415092/SnoopCompileBot/src/snoop_bench.jl#L105-L134">source</a></section><section><div><pre><code class="language-none">snoop_bench(config::BotConfig, test_modul::Module = Main)</code></pre><p>Benchmark your precompile files using the package&#39;s <code>runtests.jl</code> file.</p><p>During snooping, <code>snoop_bench</code> sets the global variable <code>SnoopCompile_ENV</code> to <code>true</code>. If needed, your <code>runtests.jl</code> can check for the existence and value of this variable to customize test behavior specifically for snooping. ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/55863ae5561dfb91723633579968ce98d0415092/SnoopCompileBot/src/snoop_bench.jl#L145-L154">source</a></section><section><div><pre><code class="language-none">snoop_bench(config::BotConfig, expression::Expr, test_modul::Module = Main)</code></pre><p>Benchmark your precompile files by evaluating an expression, for example <code>:(using MyPackage)</code>. Interpolation and macros are not supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/55863ae5561dfb91723633579968ce98d0415092/SnoopCompileBot/src/snoop_bench.jl#L160-L165">source</a></section></article><h2 id="Snoop-bot-utilities-1"><a class="docs-heading-anchor" href="#Snoop-bot-utilities-1">Snoop bot utilities</a><a class="docs-heading-anchor-permalink" href="#Snoop-bot-utilities-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SnoopCompileBot.pathof_noload" href="#SnoopCompileBot.pathof_noload"><code>SnoopCompileBot.pathof_noload</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns a package&#39;s path without loading the package in the main Julia process. May launch a separate Julia process to find the package.</p><p><strong>Examples</strong></p><pre><code class="language-julia">pathof_noload(&quot;MatLang&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/55863ae5561dfb91723633579968ce98d0415092/SnoopCompileBot/src/botutils.jl#L209-L217">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../snoopr/">« Snooping on and fixing invalidations: <code>@snoopr</code></a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 1 July 2020 00:50">Wednesday 1 July 2020</span>. Using Julia version 1.6.0-DEV.326.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
