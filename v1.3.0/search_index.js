var documenterSearchIndex = {"docs":
[{"location":"bot/#SnoopCompile-Bot-(EXPERIMENTAL)-1","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"","category":"section"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"You can use SnoopCompile bot to automatically and continuously create precompile files.","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"One should add 3 things to a package to make the bot work:","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"Workflow file:","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"create a workflow file with this path in your repository .github/workflows/SnoopCompile.yml and use the following content:","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"name: SnoopCompile\n\non:\n  - push\n\n\njobs:\n  build:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        julia-version: ['1.4.0-rc1'] # using 1.4 and higher is better\n        julia-arch: [x64]\n        os: [ubuntu-latest]\n    steps:\n      - uses: actions/checkout@v2\n      - uses: julia-actions/setup-julia@latest\n        with:\n          version: ${{ matrix.julia-version }}\n      - name: Install dependencies\n        run: julia --project -e 'using Pkg; Pkg.instantiate();'\n      - name : Add SnoopCompile and current package\n        run: julia -e 'using Pkg; Pkg.add(\"SnoopCompile\"); Pkg.develop(PackageSpec(; path=pwd()));'\n      - name: Install Test dependencies\n        run: julia -e 'using SnoopCompile; SnoopCompile.addtestdep()'\n      - name: Generating precompile files\n        run: julia --project=@. -e 'include(\"deps/SnoopCompile/snoopCompile.jl\")'\n      - name: Running Benchmark\n        run: julia --project=@. -e 'include(\"deps/SnoopCompile/snoopBenchmark.jl\")'\n\n      # https://github.com/marketplace/actions/create-pull-request\n      - name: Create Pull Request\n        uses: peter-evans/create-pull-request@v2\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          commit-message: Update precompile_*.jl file\n          committer: YOUR NAME <yourEmail@something.com> # Change `committer` to your name and your email.\n          title: '[AUTO] Update precompile_*.jl file'\n          labels: SnoopCompile\n          branch: create-pull-request/SnoopCompile\n      - name: Check output environment variable\n        run: echo \"Pull Request Number - ${{ env.PULL_REQUEST_NUMBER }}\"","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"Install Test dependencies step is only needed if you have test dependencies other than Test. Otherwise, you should comment it. In this case, if your examples or tests have dependencies, you should add a Test.toml to your test folder.","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"- name: Install Test dependencies\n  run: julia -e 'using SnoopCompile; SnoopCompile.addtestdep()'","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"For example for MatLang package:","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"Link","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"Precompile script","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"Add a snoopCompile.jl file under deps/SnoopCompile. The content of the file should be a script that \"exercises\" the functionality you'd like to precompile. One option is to use your package's \"runtests.jl\" file, or you can write a custom script for this purpose.","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"For example, some examples that call the functions:","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"using SnoopCompile\n\n@snoopi_bot \"MatLang\" begin\n  using MatLang\n  examplePath = joinpath(dirname(dirname(pathof(MatLang))), \"examples\")\n  include(joinpath(examplePath,\"Language_Fundamentals\", \"usage_Entering_Commands.jl\"))\n  include(joinpath(examplePath,\"Language_Fundamentals\", \"usage_Matrices_and_Arrays.jl\"))\n  include(joinpath(examplePath,\"Language_Fundamentals\", \"Data_Types\", \"usage_Numeric_Types.jl\"))\nend","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"Ref","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"or if you do not have additional examples, you can use your runtests.jl file using this syntax:","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"using SnoopCompile\n\n# using runtests:\n@snoopi_bot \"MatLang\"","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"Also look at this","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"Include precompile signatures","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"Two lines of (commented) code that includes the precompile file in your main module.","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"It is better to have these lines commented to continuously develop and change your package offline. snoopi_bot will find these lines of code and will uncomment them in the created pull request. If they are not commented the bot will leave it as is in the pull request:","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"# include(\"../deps/SnoopCompile/precompile/precompile_MatLang.jl\")\n# _precompile_()","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"Ref","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"","category":"page"},{"location":"bot/#Benchmark-1","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"Benchmark","text":"","category":"section"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"To measure the effect of adding precompile files. Add a snoopBenchmark.jl. The content of this file can be the following:","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"Benchmarking the load infer time","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"println(\"loading infer benchmark\")\n\n@snoopi_bench \"MatLang\" using MatLang","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"Benchmarking the example infer time","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"println(\"examples infer benchmark\")\n\n@snoopi_bench \"MatLang\" begin\n    using MatLang\n    examplePath = joinpath(dirname(dirname(pathof(MatLang))), \"examples\")\n    # include(joinpath(examplePath,\"Language_Fundamentals\", \"usage_Entering_Commands.jl\"))\n    include(joinpath(examplePath,\"Language_Fundamentals\", \"usage_Matrices_and_Arrays.jl\"))\n    include(joinpath(examplePath,\"Language_Fundamentals\", \"Data_Types\", \"usage_Numeric_Types.jl\"))\nend","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"Benchmarking the tests:","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"@snoopi_bench \"MatLang\"","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"Ref","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"To run the benchmark online, add the following to your yaml file after Generating precompile files step:","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot (EXPERIMENTAL)","title":"SnoopCompile Bot (EXPERIMENTAL)","text":"- name: Running Benchmark\n  run: julia --project=@. -e 'include(\"deps/SnoopCompile/snoopBenchmark.jl\")'","category":"page"},{"location":"userimg/#userimg-1","page":"Creating userimg.jl files","title":"Creating userimg.jl files","text":"","category":"section"},{"location":"userimg/#","page":"Creating userimg.jl files","title":"Creating userimg.jl files","text":"If you want to save more precompile information, one option is to create a \"userimg.jl\" file with which to build Julia. This is only supported for @snoopc. Instead of calling SnoopCompile.parcel and SnoopCompile.write, use the following:","category":"page"},{"location":"userimg/#","page":"Creating userimg.jl files","title":"Creating userimg.jl files","text":"# Use these two lines if you want to add to your userimg.jl\npc = SnoopCompile.format_userimg(reverse!(data[2]))\nSnoopCompile.write(\"/tmp/userimg_Images.jl\", pc)","category":"page"},{"location":"userimg/#","page":"Creating userimg.jl files","title":"Creating userimg.jl files","text":"Now move the resulting file to your Julia source directory, and create a userimg.jl file that includes all the package-specific precompile files you want. Then build Julia from source. You should note that your latencies decrease substantially.","category":"page"},{"location":"userimg/#","page":"Creating userimg.jl files","title":"Creating userimg.jl files","text":"There are serious negatives associated with a userimg.jl script:","category":"page"},{"location":"userimg/#","page":"Creating userimg.jl files","title":"Creating userimg.jl files","text":"Your julia build times become very long\nPkg.update() will have no effect on packages that you've built into julia until you next recompile julia itself. Consequently, you may not get the benefit of enhancements or bug fixes.\nFor a package that you sometimes develop, this strategy is very inefficient, because testing a change means rebuilding Julia as well as your package.","category":"page"},{"location":"userimg/#","page":"Creating userimg.jl files","title":"Creating userimg.jl files","text":"A process similar to this one is also performed via PackageCompiler.","category":"page"},{"location":"snoopc/#Snooping-on-code-generation:-@snoopc-1","page":"Snooping on code generation: @snoopc","title":"Snooping on code generation: @snoopc","text":"","category":"section"},{"location":"snoopc/#","page":"Snooping on code generation: @snoopc","title":"Snooping on code generation: @snoopc","text":"@snoopc has the advantage of working on any modern version of Julia. It \"snoops\" on the code-generation phase of compilation (the 'c' is a reference to code-generation). Note that while native code is not cached, it nevertheless reveals which methods are being compiled.","category":"page"},{"location":"snoopc/#","page":"Snooping on code generation: @snoopc","title":"Snooping on code generation: @snoopc","text":"Note that unlike @snoopi, @snoopc will generate all methods, not just the top-level methods that trigger compilation. (It is redundant to precompile dependent methods, but neither is it harmful.) It is also worth noting that @snoopc requires \"spinning up\" a new Julia process, and so it is a bit slower than @snoopi.","category":"page"},{"location":"snoopc/#","page":"Snooping on code generation: @snoopc","title":"Snooping on code generation: @snoopc","text":"Let's demonstrate @snoopc with a snoop script, in this case for the ColorTypes package:","category":"page"},{"location":"snoopc/#","page":"Snooping on code generation: @snoopc","title":"Snooping on code generation: @snoopc","text":"using SnoopCompile\n\n### Log the compiles\n# This only needs to be run once (to generate \"/tmp/colortypes_compiles.log\")\n\nSnoopCompile.@snoopc \"/tmp/colortypes_compiles.log\" begin\n    using ColorTypes, Pkg\n    include(joinpath(dirname(dirname(pathof(ColorTypes))), \"test\", \"runtests.jl\"))\nend\n\n### Parse the compiles and generate precompilation scripts\n# This can be run repeatedly to tweak the scripts\n\ndata = SnoopCompile.read(\"/tmp/colortypes_compiles.log\")\n\npc = SnoopCompile.parcel(reverse!(data[2]))\nSnoopCompile.write(\"/tmp/precompile\", pc)","category":"page"},{"location":"snoopc/#","page":"Snooping on code generation: @snoopc","title":"Snooping on code generation: @snoopc","text":"As with @snoopi, the \"/tmp/precompile\" folder will now contain a number of *.jl files, organized by package. For each package, you could copy its corresponding *.jl file into the package's src/ directory and include it into the package as described for @snoopi.","category":"page"},{"location":"snoopc/#","page":"Snooping on code generation: @snoopc","title":"Snooping on code generation: @snoopc","text":"There are more complete example illustrating potential options in the examples/ directory.","category":"page"},{"location":"snoopc/#Additional-flags-1","page":"Snooping on code generation: @snoopc","title":"Additional flags","text":"","category":"section"},{"location":"snoopc/#","page":"Snooping on code generation: @snoopc","title":"Snooping on code generation: @snoopc","text":"When calling the @snoopc macro, a new julia process is spawned using the function Base.julia_cmd(). Advanced users may want to tweak the flags passed to this process to suit specific needs. This can be done by passing an array of flags of the form [\"--flag1\", \"--flag2\"] as the first argument to the @snoop macro. For instance, if you want to pass the --project=/path/to/dir flag to the process, to cause the julia process to load the project specified by the path, a snoop script may look like:","category":"page"},{"location":"snoopc/#","page":"Snooping on code generation: @snoopc","title":"Snooping on code generation: @snoopc","text":"using SnoopCompile\n\nSnoopCompile.@snoopc [\"--project=/path/to/dir\"] \"/tmp/compiles.csv\" begin\n    # ... statement to snoop on\nend\n\n# ... processing the precompile statements","category":"page"},{"location":"reference/#Reference-1","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"@snoopi\n@snoopc\nSnoopCompile.parcel\nSnoopCompile.write\nSnoopCompile.read\nSnoopCompile.format_userimg\ntimesum","category":"page"},{"location":"reference/#SnoopCompile.@snoopi","page":"Reference","title":"SnoopCompile.@snoopi","text":"inf_timing = @snoopi commands\ninf_timing = @snoopi tmin=0.0 commands\n\nExecute commands while snooping on inference. Returns an array of (t, linfo) tuples, where t is the amount of time spent infering linfo (a MethodInstance).\n\nMethods that take less time than tmin will not be reported.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#SnoopCompile.@snoopc","page":"Reference","title":"SnoopCompile.@snoopc","text":"@snoopc \"compiledata.csv\" begin\n    # Commands to execute, in a new process\nend\n\ncauses the julia compiler to log all functions compiled in the course of executing the commands to the file \"compiledata.csv\". This file can be used for the input to SnoopCompile.read.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#SnoopCompile.parcel","page":"Reference","title":"SnoopCompile.parcel","text":"pc = parcel(calls; subst=[], blacklist=[]) assigns each compile statement to the module that owns the function. Perform string substitution via subst=[\"Module1\"=>\"Module2\"], and omit functions in particular modules with blacklist=[\"Module3\"]. On output, pc[:Module2] contains all the precompiles assigned to Module2.\n\nUse SnoopCompile.write(prefix, pc) to generate a series of files in directory prefix, one file per module.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SnoopCompile.write","page":"Reference","title":"SnoopCompile.write","text":"write(prefix::AbstractString, pc::Dict; always::Bool = false)\n\nWrite each modules' precompiles to a separate file.  If always is true, the generated function will always run the precompile statements when called, otherwise the statements will only be called during package precompilation.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SnoopCompile.read","page":"Reference","title":"SnoopCompile.read","text":"SnoopCompile.read(\"compiledata.csv\") reads the log file produced by the compiler and returns the functions as a pair of arrays. The first array is the amount of time required to compile each function, the second is the corresponding function + types. The functions are sorted in order of increasing compilation time. (The time does not include the cost of nested compiles.)\n\n\n\n\n\n","category":"function"},{"location":"reference/#SnoopCompile.format_userimg","page":"Reference","title":"SnoopCompile.format_userimg","text":"pc = format_userimg(calls; subst=[], blacklist=[]) generates precompile directives intended for your base/userimg.jl script. Use SnoopCompile.write(filename, pc) to create a file that you can include into userimg.jl.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SnoopCompile.timesum","page":"Reference","title":"SnoopCompile.timesum","text":"timesum(snoop)\n\nCalculates and prints the total time measured by a snoop macro.\n\nIt is used inside @snoopibench. Julia can cache inference results so to measure the effect of adding _precompile() sentences generated by snoopi to your package, use the @snoopi_bench. This benchmark measures inference time taken during loading and running of a package.\n\nExamples\n\nusing SnoopCompile\ndata = @snoopi begin\n    include(joinpath(dirname(dirname(pathof(MatLang))),\"test\",\"runtests.jl\"))\nend;\nprintln(timesum(data));\n\nManual Benchmark (withtout using @snoopi_bench)\n\ndev your package\ncomment the precompile part of your package (include() and _precompile_())\nrun the following benchmark\nrestart Julia\nuncomment the precompile part of your package (include() and _precompile_())\nrun the following benchmark\nrestart Julia\n\nBenchmark\n\nusing SnoopCompile\n\nprintln(\"Package load time:\")\nloadSnoop = @snoopi using MatLang\n\ntimesum(loadSnoop)\n\nprintln(\"Running Examples/Tests:\")\nrunSnoop = @snoopi begin\n    using MatLang\n    include(joinpath(dirname(dirname(pathof(MatLang))),\"test\",\"runtests.jl\"))\nend\n\ntimesum(runSnoop)\n\n\n\n\n\n","category":"function"},{"location":"#SnoopCompile.jl-1","page":"SnoopCompile.jl","title":"SnoopCompile.jl","text":"","category":"section"},{"location":"#","page":"SnoopCompile.jl","title":"SnoopCompile.jl","text":"SnoopCompile \"snoops\" on the Julia compiler, causing it to record the functions and argument types it's compiling.  From these lists of methods, you can generate lists of precompile directives that may reduce the latency between loading packages and using them to do \"real work.\"","category":"page"},{"location":"#","page":"SnoopCompile.jl","title":"SnoopCompile.jl","text":"SnoopCompile can also detect and analyze method cache invalidations, which occur when new method definitions alter dispatch in a way that forces Julia to discard previously-compiled code. Any later usage of invalidated methods requires recompilation. Invalidation can trigger a domino effect, in which all users of invalidated code also become invalidated, propagating all the way back to the top-level call. When a source of invalidation can be identified and either eliminated or mitigated, you can reduce the amount of work that the compiler needs to repeat and take better advantage of precompilation.","category":"page"},{"location":"#Background-1","page":"SnoopCompile.jl","title":"Background","text":"","category":"section"},{"location":"#","page":"SnoopCompile.jl","title":"SnoopCompile.jl","text":"Julia uses Just-in-time (JIT) compilation to generate the code that runs on your CPU. Broadly speaking, there are two major steps: inference and code generation. Inference is the process of determining the type of each object, which in turn determines which specific methods get called; once type inference is complete, code generation performs optimizations and ultimately generates the assembly language (native code) used on CPUs. Some aspects of this process are documented here.","category":"page"},{"location":"#","page":"SnoopCompile.jl","title":"SnoopCompile.jl","text":"Every time you load a package in a fresh Julia session, the methods you use need to be JIT-compiled, and this contributes to the latency of using the package. In some circumstances, you can save some of the work to reduce the burden next time. This is called precompilation. Unfortunately, precompilation is not as comprehensive as one might hope. Currently, Julia is only capable of saving inference results (not native code) in the *.ji files that are the result of precompilation. Moreover, there are some significant constraints that sometimes prevent Julia from saving even the inference results; and finally, what does get saved can sometimes be invalidated if later packages provide more specific methods that supersede some of the calls in the precompiled methods.","category":"page"},{"location":"#","page":"SnoopCompile.jl","title":"SnoopCompile.jl","text":"Despite these limitations, there are cases where precompilation can substantially reduce latency. SnoopCompile is designed to try to make it easy to try precompilation to see whether it produces measurable benefits.","category":"page"},{"location":"#Who-should-use-this-package-1","page":"SnoopCompile.jl","title":"Who should use this package","text":"","category":"section"},{"location":"#","page":"SnoopCompile.jl","title":"SnoopCompile.jl","text":"SnoopCompile is intended primarily for package developers who want to improve the experience for their users. Because the results of SnoopCompile are typically stored in the *.ji precompile files, anyone can take advantage of the reduced latency.","category":"page"},{"location":"#","page":"SnoopCompile.jl","title":"SnoopCompile.jl","text":"PackageCompiler is an alternative that non-developer users may want to consider for their own workflow. It performs more thorough precompilation than the \"standard\" usage of SnoopCompile, although one can achieve a similar effect by creating userimg.jl files. However, the cost is vastly increased build times, which for package developers is unlikely to be productive.","category":"page"},{"location":"#","page":"SnoopCompile.jl","title":"SnoopCompile.jl","text":"Finally, another alternative that reduces latency without any modifications to package files is Revise. It can be used in conjunction with SnoopCompile.","category":"page"},{"location":"snoopi/#Snooping-on-inference:-@snoopi-1","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"","category":"section"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"The most useful tool is a macro, @snoopi, which is only available on Julia 1.2 or higher.","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"Julia can cache inference results, so you can use @snoopi to generate precompile directives for your package. Executing these directives when the package is compiled may reduce compilation (inference) time when the package is used.","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"Here's a quick demo:","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"using SnoopCompile\n\na = rand(Float16, 5)\n\njulia> inf_timing = @snoopi sum(a)\n1-element Array{Tuple{Float64,Core.MethodInstance},1}:\n (0.011293888092041016, MethodInstance for sum(::Array{Float16,1}))","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"We defined the argument a, and then called sum(a) while \"snooping\" on inference. (The i in @snoopi means \"inference.\") The return is a list of \"top level\" methods that got compiled, together with the amount of time spent on inference. In this case it was just a single method, which required approximately 11ms of inference time. (Inferring sum required inferring all the methods that it calls, but these are subsumed into the top level inference of sum itself.) Note that the method that got called,","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"julia> @which sum(a)\nsum(a::AbstractArray) in Base at reducedim.jl:652","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"is much more general (i.e., defined for AbstractArray) than the MethodInstance (defined for Array{Float16,1}). This is because precompilation happens only for concrete objects passed as arguments.","category":"page"},{"location":"snoopi/#Precompile-scripts-1","page":"Snooping on inference: @snoopi","title":"Precompile scripts","text":"","category":"section"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"You can use @snoopi to come up with a list of precompile-worthy functions. A recommended approach is to write a script that \"exercises\" the functionality you'd like to precompile. One option is to use your package's \"runtests.jl\" file, or you can write a custom script for this purpose. Here's an example for the FixedPointNumbers package:","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"using FixedPointNumbers\n\nx = N0f8(0.2)\ny = x + x\ny = x - x\ny = x*x\ny = x/x\ny = Float32(x)\ny = Float64(x)\ny = 0.3*x\ny = x*0.3\ny = 2*x\ny = x*2\ny = x/15\ny = x/8.0","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"Save this as a file \"snoopfpn.jl\" and navigate at the Julia REPL to that directory, and then do","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"julia> using SnoopCompile\n\njulia> inf_timing = @snoopi tmin=0.01 include(\"snoopfpn.jl\")\n2-element Array{Tuple{Float64,Core.MethodInstance},1}:\n (0.03108978271484375, MethodInstance for *(::Normed{UInt8,8}, ::Normed{UInt8,8}))\n (0.04189491271972656, MethodInstance for Normed{UInt8,8}(::Float64))             ","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"Here, note the tmin=0.01, which causes any methods that take less than 10ms of inference time to be discarded.","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"note: Note\nIf you're testing this, you might get different results depending on the speed of your machine. Moreover, if FixedPointNumbers has already precompiled these method and type combinations–-perhaps by incorporating a precompile file produced by SnoopCompile–-then those methods will be absent. If you want to try this example, dev FixedPointNumbers and disable any _precompile_() call you find.","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"You can inspect these results and write your own precompile file, or use the automated tools provided by SnoopCompile.","category":"page"},{"location":"snoopi/#auto-1","page":"Snooping on inference: @snoopi","title":"Producing precompile directives automatically","text":"","category":"section"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"You can take the output of @snoopi and \"parcel\" it into packages:","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"julia> pc = SnoopCompile.parcel(inf_timing)\nDict{Symbol,Array{String,1}} with 1 entry:\n  :FixedPointNumbers => [\"precompile(Tuple{typeof(*),Normed{UInt8,8},Normed{UInt8,8}})\", \"precompile(Tuple{Type{Normed{UInt8,8}},Float64})\"]","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"This splits the calls up into a dictionary, pc, indexed by the package which \"owns\" each call. (In this case there is only one, FixedPointNumbers, but in more complex cases there may be several.) You can then write the results to files:","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"julia> SnoopCompile.write(\"/tmp/precompile\", pc)","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"If you look in the /tmp/precompile directory, you'll see one or more files, named by their parent package, that may be suitable for includeing into the package. In this case:","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"/tmp/precompile$ cat precompile_FixedPointNumbers.jl\nfunction _precompile_()\n    ccall(:jl_generating_output, Cint, ()) == 1 || return nothing\n    precompile(Tuple{typeof(*),Normed{UInt8,8},Normed{UInt8,8}})\n    precompile(Tuple{Type{Normed{UInt8,8}},Float64})\nend","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"If you copy this file to a precompile.jl file in the src directory, you can incorporate it into the package like this:","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"module FixedPointNumbers\n\n# All the usual commands that define the module go here\n\n# ... followed by:\n\ninclude(\"precompile.jl\")\n_precompile_()\n\nend # module FixedPointNumbers","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"The listed method/type combinations should have their inference results cached. Load the package once to precompile it, and then in a fresh Julia session try this:","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"julia> using SnoopCompile\n\njulia> inf_timing = @snoopi tmin=0.01 include(\"snoopfpn.jl\")\n0-element Array{Tuple{Float64,Core.MethodInstance},1}","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"The fact that no methods were returned is a sign of success: Julia didn't need to call inference on those methods, because it used the inference results from the cache file.","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"note: Note\nSometimes, @snoopi will show method & type combinations that you precompiled. This is a sign that despite your attempts, Julia declined to cache the inference results for those methods. You can either delete those directives from the precompile file, or hope that they will become useful in a future version of Julia. Note that having many \"useless\" precompile directives can slow down precompilation.","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"note: Note\nAs you develop your package, it's possible you'll modify or delete some of the methods that appear in your \"precompile.jl\" file. This will not result in an error; by default precompile fails silently. If you want to be certain that your precompile directives don't go stale, preface each with an @assert. Note that this forces you to update your precompile directives as you modify your package, which may or may not be desirable.","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"If you find that some precompile directives are ineffective (they appear in a new @snoopi despite being precompiled) and their inference time is substantial, sometimes a bit of manual investigation of the callees can lead to insights. For example, you might be able to introduce a precompile in a dependent package that can mitigate the total time.","category":"page"},{"location":"snoopi/#Producing-precompile-directives-manually-1","page":"Snooping on inference: @snoopi","title":"Producing precompile directives manually","text":"","category":"section"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"While this \"automated\" approach is often useful, sometimes it makes more sense to inspect the results and write your own precompile directives. For example, for FixedPointNumbers a more elegant and comprehensive precompile file might be","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"function _precompile_()\n    ccall(:jl_generating_output, Cint, ()) == 1 || return nothing\n    for T in (N0f8, N0f16)      # Normed types we want to support\n        for f in (+, -, *, /)   # operations we want to support\n            precompile(Tuple{typeof(f),T,T})\n            for S in (Float32, Float64, Int)   # other number types we want to support\n                precompile(Tuple{typeof(f),T,S})\n                precompile(Tuple{typeof(f),S,T})\n            end\n        end\n        for S in (Float32, Float64)\n            precompile(Tuple{Type{T},S})\n            precompile(Tuple{Type{S},T})\n        end\n    end\nend","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"This covers +, -, *, /, and conversion for various combinations of types. The results from @snoopi can suggest method/type combinations that might be useful to precompile, but often you can generalize its suggestions in useful ways.","category":"page"},{"location":"snoopi/#Analyzing-omitted-methods-1","page":"Snooping on inference: @snoopi","title":"Analyzing omitted methods","text":"","category":"section"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"There are some method signatures that cannot be precompiled. For example, suppose you have two packages, A and B, that are independent of one another. Then A.f([B.Object(1)]) cannot be precompiled, because A does not know about B.Object, and B does not know about A.f, unless both A and B get included into a third package.","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"Such problematic method signatures are removed automatically. If you want to be informed about these removals, you can use Julia's logging framework while running parcel:","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"julia> using Base.CoreLogging\n\njulia> logger = SimpleLogger(IOBuffer(), CoreLogging.Debug);\n\njulia> pc = with_logger(logger) do\n           SnoopCompile.parcel(inf_timing)\n       end\n\njulia> msgs = String(take!(logger.stream))","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"The omitted method signatures will be logged to the string msgs.","category":"page"},{"location":"snoopr/#Snooping-on-invalidations:-@snoopr-1","page":"Snooping on invalidations: @snoopr","title":"Snooping on invalidations: @snoopr","text":"","category":"section"},{"location":"snoopr/#Recording-invalidations-1","page":"Snooping on invalidations: @snoopr","title":"Recording invalidations","text":"","category":"section"},{"location":"snoopr/#","page":"Snooping on invalidations: @snoopr","title":"Snooping on invalidations: @snoopr","text":"DocTestFilters = r\"(REPL\\[\\d+\\]|none):\\d+\"\nDocTestSetup = quote\n    using SnoopCompile\nend","category":"page"},{"location":"snoopr/#","page":"Snooping on invalidations: @snoopr","title":"Snooping on invalidations: @snoopr","text":"Invalidations occur when there is a danger that new methods would supersede older methods in previously-compiled code. We can illustrate this process with the following example:","category":"page"},{"location":"snoopr/#","page":"Snooping on invalidations: @snoopr","title":"Snooping on invalidations: @snoopr","text":"julia> f(::Real) = 1;\n\njulia> callf(container) = f(container[1]);\n\njulia> call2f(container) = callf(container);","category":"page"},{"location":"snoopr/#","page":"Snooping on invalidations: @snoopr","title":"Snooping on invalidations: @snoopr","text":"Let's run this with different container types:","category":"page"},{"location":"snoopr/#","page":"Snooping on invalidations: @snoopr","title":"Snooping on invalidations: @snoopr","text":"julia> c64  = [1.0]; c32 = [1.0f0]; cabs = AbstractFloat[1.0];\n\njulia> call2f(c64)\n1\n\njulia> call2f(c32)\n1\n\njulia> call2f(cabs)\n1","category":"page"},{"location":"snoopr/#","page":"Snooping on invalidations: @snoopr","title":"Snooping on invalidations: @snoopr","text":"It's important that you actually execute these methods: code doesn't get compiled until it gets run, and invalidations only affect compiled code.","category":"page"},{"location":"snoopr/#","page":"Snooping on invalidations: @snoopr","title":"Snooping on invalidations: @snoopr","text":"Now we'll define a new f method, one specialized for Float64. So we can see the consequences for the compiled code, we'll make this definition while snooping on the compiler with @snoopr:","category":"page"},{"location":"snoopr/#","page":"Snooping on invalidations: @snoopr","title":"Snooping on invalidations: @snoopr","text":"julia> trees = invalidation_trees(@snoopr f(::Float64) = 2)\n1-element Array{SnoopCompile.MethodInvalidations,1}:\n insert f(::Float64) in Main at REPL[9]:1 invalidated:\n   backedges: 1: superseding f(::Real) in Main at REPL[2]:1 with MethodInstance for f(::Float64) (2 children) more specific\n              2: superseding f(::Real) in Main at REPL[2]:1 with MethodInstance for f(::AbstractFloat) (2 children) more specific","category":"page"},{"location":"snoopr/#","page":"Snooping on invalidations: @snoopr","title":"Snooping on invalidations: @snoopr","text":"The list of MethodInvalidations indicates that some previously-compiled code got invalidated. In this case, \"insert f(::Float64)\" means that a new method, for f(::Float64), was added. There were two proximal triggers for the invalidation, both of which superseded the method f(::Real). One of these had been compiled specifically for Float64, due to our call2f(c64). The other had been compiled specifically for AbstractFloat, due to our call2f(cabs).","category":"page"},{"location":"snoopr/#","page":"Snooping on invalidations: @snoopr","title":"Snooping on invalidations: @snoopr","text":"You can look at these invalidation trees in greater detail:","category":"page"},{"location":"snoopr/#","page":"Snooping on invalidations: @snoopr","title":"Snooping on invalidations: @snoopr","text":"julia> tree = trees[1];\n\njulia> root = tree.backedges[1]\nMethodInstance for f(::Float64) at depth 0 with 2 children\n\njulia> show(root)\nMethodInstance for f(::Float64) (2 children)\n MethodInstance for callf(::Array{Float64,1}) (1 children)\n ⋮\n\njulia> show(root; minchildren=0)\nMethodInstance for f(::Float64) (2 children)\n MethodInstance for callf(::Array{Float64,1}) (1 children)\n  MethodInstance for call2f(::Array{Float64,1}) (0 children)","category":"page"},{"location":"snoopr/#","page":"Snooping on invalidations: @snoopr","title":"Snooping on invalidations: @snoopr","text":"You can see that the sequence of invalidations proceeded all the way up to call2f. Examining root2 = tree.backedges[2] yields similar results, but for Array{AbstractFloat,1}.","category":"page"},{"location":"snoopr/#","page":"Snooping on invalidations: @snoopr","title":"Snooping on invalidations: @snoopr","text":"The structure of these trees can be considerably more complicated. For example, if callf also got called by some other method, and that method had also been executed (forcing it to be compiled), then callf would have multiple children. This is often seen with more complex, real-world tests:","category":"page"},{"location":"snoopr/#","page":"Snooping on invalidations: @snoopr","title":"Snooping on invalidations: @snoopr","text":"julia> trees = invalidation_trees(@snoopr using SIMD)\n4-element Array{SnoopCompile.MethodInvalidations,1}:\n insert convert(::Type{Tuple{Vararg{R,N}}}, v::Vec{N,T}) where {N, R, T} in SIMD at /home/tim/.julia/packages/SIMD/Am38N/src/SIMD.jl:182 invalidated:\n   mt_backedges: 1: signature Tuple{typeof(convert),Type{Tuple{DataType,DataType,DataType}},Any} triggered MethodInstance for Pair{DataType,Tuple{DataType,DataType,DataType}}(::Any, ::Any) (0 children) ambiguous\n                 2: signature Tuple{typeof(convert),Type{NTuple{8,DataType}},Any} triggered MethodInstance for Pair{DataType,NTuple{8,DataType}}(::Any, ::Any) (0 children) ambiguous\n                 3: signature Tuple{typeof(convert),Type{NTuple{7,DataType}},Any} triggered MethodInstance for Pair{DataType,NTuple{7,DataType}}(::Any, ::Any) (0 children) ambiguous\n\n insert convert(::Type{Tuple}, v::Vec{N,T}) where {N, T} in SIMD at /home/tim/.julia/packages/SIMD/Am38N/src/SIMD.jl:188 invalidated:\n   mt_backedges: 1: signature Tuple{typeof(convert),Type{Tuple},Any} triggered MethodInstance for Distributed.RemoteDoMsg(::Any, ::Any, ::Any) (1 children) more specific\n                 2: signature Tuple{typeof(convert),Type{Tuple},Any} triggered MethodInstance for Distributed.CallMsg{:call}(::Any, ::Any, ::Any) (1 children) more specific\n                 3: signature Tuple{typeof(convert),Type{Tuple},Any} triggered MethodInstance for Distributed.CallMsg{:call_fetch}(::Any, ::Any, ::Any) (1 children) more specific\n                 4: signature Tuple{typeof(convert),Type{Tuple},Any} triggered MethodInstance for Distributed.CallWaitMsg(::Any, ::Any, ::Any) (4 children) more specific\n   12 mt_cache\n\n insert <<(x1::T, v2::Vec{N,T}) where {N, T<:Union{Bool, Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}} in SIMD at /home/tim/.julia/packages/SIMD/Am38N/src/SIMD.jl:1061 invalidated:\n   mt_backedges: 1: signature Tuple{typeof(<<),UInt64,Any} triggered MethodInstance for <<(::UInt64, ::Integer) (0 children) ambiguous\n                 2: signature Tuple{typeof(<<),UInt64,Any} triggered MethodInstance for copy_chunks_rtol!(::Array{UInt64,1}, ::Integer, ::Integer, ::Integer) (0 children) ambiguous\n                 3: signature Tuple{typeof(<<),UInt64,Any} triggered MethodInstance for copy_chunks_rtol!(::Array{UInt64,1}, ::Int64, ::Int64, ::Integer) (0 children) ambiguous\n                 4: signature Tuple{typeof(<<),UInt64,Any} triggered MethodInstance for copy_chunks_rtol!(::Array{UInt64,1}, ::Integer, ::Int64, ::Integer) (0 children) ambiguous\n                 5: signature Tuple{typeof(<<),UInt64,Any} triggered MethodInstance for <<(::UInt64, ::Unsigned) (16 children) ambiguous\n   20 mt_cache\n\n insert +(s1::Union{Bool, Float16, Float32, Float64, Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8, Ptr}, v2::Vec{N,T}) where {N, T<:Union{Float16, Float32, Float64}} in SIMD at /home/tim/.julia/packages/SIMD/Am38N/src/SIMD.jl:1165 invalidated:\n   mt_backedges:  1: signature Tuple{typeof(+),Ptr{UInt8},Any} triggered MethodInstance for handle_err(::JuliaInterpreter.Compiled, ::JuliaInterpreter.Frame, ::Any) (0 children) ambiguous\n                  2: signature Tuple{typeof(+),Ptr{UInt8},Any} triggered MethodInstance for #methoddef!#5(::Bool, ::typeof(LoweredCodeUtils.methoddef!), ::Any, ::Set{Any}, ::JuliaInterpreter.Frame) (0 children) ambiguous\n                  3: signature Tuple{typeof(+),Ptr{UInt8},Any} triggered MethodInstance for #get_def#94(::Set{Tuple{Revise.PkgData,String}}, ::typeof(Revise.get_def), ::Method) (0 children) ambiguous\n                  4: signature Tuple{typeof(+),Ptr{Nothing},Any} triggered MethodInstance for filter_valid_cachefiles(::String, ::Array{String,1}) (0 children) ambiguous\n                  5: signature Tuple{typeof(+),Ptr{Union{Int64, Symbol}},Any} triggered MethodInstance for pointer(::Array{Union{Int64, Symbol},N} where N, ::Int64) (1 children) ambiguous\n                  6: signature Tuple{typeof(+),Ptr{Char},Any} triggered MethodInstance for pointer(::Array{Char,N} where N, ::Int64) (2 children) ambiguous\n                  7: signature Tuple{typeof(+),Ptr{_A} where _A,Any} triggered MethodInstance for pointer(::Array{T,N} where N where T, ::Int64) (4 children) ambiguous\n                  8: signature Tuple{typeof(+),Ptr{Nothing},Any} triggered MethodInstance for _show_default(::IOContext{Base.GenericIOBuffer{Array{UInt8,1}}}, ::Any) (49 children) ambiguous\n                  9: signature Tuple{typeof(+),Ptr{Nothing},Any} triggered MethodInstance for _show_default(::Base.GenericIOBuffer{Array{UInt8,1}}, ::Any) (336 children) ambiguous\n                 10: signature Tuple{typeof(+),Ptr{UInt8},Any} triggered MethodInstance for pointer(::String, ::Integer) (1027 children) ambiguous\n   2 mt_cache","category":"page"},{"location":"snoopr/#","page":"Snooping on invalidations: @snoopr","title":"Snooping on invalidations: @snoopr","text":"Your specific output will surely be different from this, depending on which packages you have loaded, which versions of those packages are installed, and which version of Julia you are using. In this example, there were four different methods that triggered invalidations, and the invalidated methods were in Base, Distributed, JuliaInterpeter, and LoweredCodeUtils. (The latter two were a consequence of loading Revise.) You can see that collectively more than a thousand independent compiled methods needed to be invalidated; indeed, the last entry alone invalidates 1027 method instances:","category":"page"},{"location":"snoopr/#","page":"Snooping on invalidations: @snoopr","title":"Snooping on invalidations: @snoopr","text":"julia> sig, node = trees[end].mt_backedges[10]\nPair{Any,SnoopCompile.InstanceTree}(Tuple{typeof(+),Ptr{UInt8},Any}, MethodInstance for pointer(::String, ::Integer) at depth 0 with 1027 children)\n\njulia> node\nMethodInstance for pointer(::String, ::Integer) at depth 0 with 1027 children\n\njulia> show(node)\nMethodInstance for pointer(::String, ::Integer) (1027 children)\n MethodInstance for repeat(::String, ::Integer) (1023 children)\n  MethodInstance for ^(::String, ::Integer) (1019 children)\n   MethodInstance for #handle_message#2(::Nothing, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(Base.CoreLogging.handle_message), ::Logging.ConsoleLogger, ::Base.CoreLogging.LogLevel, ::String, ::Module, ::Symbol, ::Symbol, ::String, ::Int64) (906 children)\n    MethodInstance for handle_message(::Logging.ConsoleLogger, ::Base.CoreLogging.LogLevel, ::String, ::Module, ::Symbol, ::Symbol, ::String, ::Int64) (902 children)\n     MethodInstance for log_event_global!(::Pkg.Resolve.Graph, ::String) (35 children)\n     ⋮\n     MethodInstance for #artifact_meta#20(::Pkg.BinaryPlatforms.Platform, ::typeof(Pkg.Artifacts.artifact_meta), ::String, ::Dict{String,Any}, ::String) (43 children)\n     ⋮\n     MethodInstance for Dict{Base.UUID,Pkg.Types.PackageEntry}(::Dict) (79 children)\n     ⋮\n     MethodInstance for read!(::Base.Process, ::LibGit2.GitCredential) (80 children)\n     ⋮\n     MethodInstance for handle_err(::JuliaInterpreter.Compiled, ::JuliaInterpreter.Frame, ::Any) (454 children)\n     ⋮\n    ⋮\n   ⋮\n  ⋮\n ⋮\n⋮","category":"page"},{"location":"snoopr/#","page":"Snooping on invalidations: @snoopr","title":"Snooping on invalidations: @snoopr","text":"Many nodes in this tree have multiple \"child\" branches.","category":"page"},{"location":"snoopr/#Avoiding-or-fixing-invalidations-1","page":"Snooping on invalidations: @snoopr","title":"Avoiding or fixing invalidations","text":"","category":"section"},{"location":"snoopr/#","page":"Snooping on invalidations: @snoopr","title":"Snooping on invalidations: @snoopr","text":"Invalidations occur in situations like our call2f(c64) example, where we changed our mind about what value f should return for Float64. Julia could not have returned the newly-correct answer without recompiling the call chain.","category":"page"},{"location":"snoopr/#","page":"Snooping on invalidations: @snoopr","title":"Snooping on invalidations: @snoopr","text":"Aside from cases like these, most invalidations occur whenever new types are introduced, and some methods were previously compiled for abstract types. In some cases, this is inevitable, and the resulting invalidations simply need to be accepted as a consequence of a dynamic, updateable language. (You can often minimize invalidations by loading all your code at the beginning of your session, before triggering the compilation of more methods.) However, in many circumstances an invalidation indicates an opportunity to improve code. In our first example, note that the call call2f(c32) did not get invalidated: this is because the compiler knew all the specific types, and new methods did not affect any of those types. The main tips for writing invalidation-resistant code are:","category":"page"},{"location":"snoopr/#","page":"Snooping on invalidations: @snoopr","title":"Snooping on invalidations: @snoopr","text":"use concrete types wherever possible\nwrite inferrable code\ndon't engage in type-piracy (our c64 example is essentially like type-piracy, where we redefined behavior for a pre-existing type)","category":"page"},{"location":"snoopr/#","page":"Snooping on invalidations: @snoopr","title":"Snooping on invalidations: @snoopr","text":"Since these tips also improve performance and allow programs to behave more predictably, these guidelines are not intrusive. Indeed, searching for and eliminating invalidations can help you improve the quality of your code. In cases where invalidations occur, but you can't use concrete types (there are many valid uses of Vector{Any}), you can often prevent the invalidation using some additional knowledge. For example, suppose you're writing code that parses Julia's Expr type:","category":"page"},{"location":"snoopr/#","page":"Snooping on invalidations: @snoopr","title":"Snooping on invalidations: @snoopr","text":"julia> ex = :(Array{Float32,3})\n:(Array{Float32, 3})\n\njulia> dump(ex)\nExpr\n  head: Symbol curly\n  args: Array{Any}((3,))\n    1: Symbol Array\n    2: Symbol Float32\n    3: Int64 3","category":"page"},{"location":"snoopr/#","page":"Snooping on invalidations: @snoopr","title":"Snooping on invalidations: @snoopr","text":"ex.args is a Vector{Any}. However, for a :curly expression only certain types will be found among the arguments; you could write key portions of your code as","category":"page"},{"location":"snoopr/#","page":"Snooping on invalidations: @snoopr","title":"Snooping on invalidations: @snoopr","text":"a = ex.args[2]\nif a isa Symbol\n    # inside this block, Julia knows `a` is a Symbol, and so methods called on `a` will be resistant to invalidation\n    foo(a)\nelseif a isa Expr && length((a::Expr).args) > 2\n    a = a::Expr     # sometimes you have to help inference by adding a type-assert\n    x = bar(a)      # `bar` is now resistant to invalidation\nelsef a isa Integer\n    # even though you've not made this fully-inferrable, you've at least reduced the scope for invalidations\n    # by limiting the subset of `foobar` methods that might be called\n    y = foobar(a)\nend","category":"page"},{"location":"snoopr/#","page":"Snooping on invalidations: @snoopr","title":"Snooping on invalidations: @snoopr","text":"Adding type-assertions and fixing inference problems are the most common approaches for fixing invalidations. You can discover these manually, but the Cthulhu package is highly recommended. Cthulu's ascend, in particular, allows you to navigate an invalidation tree and focus on those branches with the most severe consequences (frequently, the most children).","category":"page"}]
}
