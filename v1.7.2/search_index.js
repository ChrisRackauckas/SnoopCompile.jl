var documenterSearchIndex = {"docs":
[{"location":"bot/#SnoopCompile-Bot-1","page":"SnoopCompile Bot","title":"SnoopCompile Bot","text":"","category":"section"},{"location":"bot/#","page":"SnoopCompile Bot","title":"SnoopCompile Bot","text":"As you change the code in your package, the precompile statements likely need to be updated too. You can use SnoopCompile bot to automatically and continuously create precompile files. This bot can be used offline or online.","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot","title":"SnoopCompile Bot","text":"Follow these steps to set up SnoopCompile bot for your package.","category":"page"},{"location":"bot/#Setting-up-the-SnoopCompile-bot-configuration-folder-1","page":"SnoopCompile Bot","title":"1 - Setting up the SnoopCompile bot configuration folder","text":"","category":"section"},{"location":"bot/#","page":"SnoopCompile Bot","title":"SnoopCompile Bot","text":"Here, we will configure the bot in a directory deps/SnoopCompile/ that should be added to your repository. All configuration files for the SnoopCompile bot should go in this directory. If you choose a different name for this directory, be sure to change the path in the configuration steps below.","category":"page"},{"location":"bot/#Create-the-precompile-script-1","page":"SnoopCompile Bot","title":"2 - Create the precompile script","text":"","category":"section"},{"location":"bot/#","page":"SnoopCompile Bot","title":"SnoopCompile Bot","text":"You will need a precompile script, here called example_script.jl, that \"exercises\" the functionality you'd like to precompile. If you write a dedicated precompile script, place it in the bot configuration folder.","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot","title":"SnoopCompile Bot","text":"Alternatively, you may use your package's \"runtests.jl\" file. While less precise about which functionality is worthy of precompilation, this can slightly simplify configuration as described below.","category":"page"},{"location":"bot/#Create-the-script-that-runs-snoop_bot-1","page":"SnoopCompile Bot","title":"3 - Create the script that runs snoop_bot","text":"","category":"section"},{"location":"bot/#","page":"SnoopCompile Bot","title":"SnoopCompile Bot","text":"The snoop_bot function generates precompile statements and writes them to a file that will be incorporated into your package. snoop_bot requires a few settings, which can be most easily generated by BotConfig. The script that runs snoop_bot should be saved in your configuration directory, with a name like snoop_bot.jl.","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot","title":"SnoopCompile Bot","text":"The example below (from here) supports multiple operating systems, multiple Julia versions, and excludes a function whose precompilation would be problematic:","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot","title":"SnoopCompile Bot","text":"using SnoopCompile\n\nbotconfig = BotConfig(\n  \"Zygote\";                            # package name (the one this configuration lives in)\n  yml_path = \"SnoopCompile.yml\"        # parse `os` and `version` from `SnoopCompile.yml`\n  exclusions = [\"SqEuclidean\"],        # exclude functions (by name) that would be problematic if precompiled\n)\n\nsnoop_bot(\n  botconfig,\n  \"$(@__DIR__)/example_script.jl\",\n)","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot","title":"SnoopCompile Bot","text":"If you choose to use your \"runtests.jl\" file as your precompile script, configuration can be as simple as specifying just the name of the package:","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot","title":"SnoopCompile Bot","text":"using SnoopCompile\n\nsnoop_bot(BotConfig(\"MyPackage\"))","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot","title":"SnoopCompile Bot","text":"note: Note\nSome of your regular tests may not be appropriate for snoop_bot. snoop_bot sets a global variable SnoopCompile_ENV to true during snooping, and sets it to false when finished. You can exploit this in your tests to determine whether snooping is on:if !isdefined(Main, :SnoopCompile_ENV) || SnoopCompile_ENV == false\n    # Tests that you want to skip when snooping\nend","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot","title":"SnoopCompile Bot","text":"Finally, you could use package loading as the only operation, with snoop_bot(config, :(using MyPackage)).","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot","title":"SnoopCompile Bot","text":"snoop_bot uses different strategies depending on the Julia version:","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot","title":"SnoopCompile Bot","text":"On Julia 1.2 or higher, it identifies methods for precompilation based on @snoopi;\nOn Julia 1.0 or 1.1 (which do not support @snoopi), it identifies methods for precompilation based on @snoopc.","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot","title":"SnoopCompile Bot","text":"You can override this default behavior with a keyword argument, see snoop_bot for details.","category":"page"},{"location":"bot/#Optionally-test-the-impact-of-your-precompiles-with-snoop_bench-1","page":"SnoopCompile Bot","title":"4 - Optionally test the impact of your precompiles with snoop_bench","text":"","category":"section"},{"location":"bot/#","page":"SnoopCompile Bot","title":"SnoopCompile Bot","text":"Call snoop_bench to measure the effect of adding precompile files. It takes the same parameters as snoop_bot above. You can run this manually, or choose to run it during automatic precompile file generation. To perform it automatically, create a snoop_bench.jl script in the bot configuration directory. This should be nearly identical to your snoop_bot.jl file, but calling snoop_bench instead. Note that benchmarking has the option of different performance metrics, snoop_mode=:snoopi or snoop_mode=:run_time depending on whether you want to measure inference time or the run time of your precompile script.","category":"page"},{"location":"bot/#Configure-the-bot-to-run-with-a-GitHub-Action-file-1","page":"SnoopCompile Bot","title":"5 - Configure the bot to run with a GitHub Action file","text":"","category":"section"},{"location":"bot/#","page":"SnoopCompile Bot","title":"SnoopCompile Bot","text":"You can create the precompile files automatically when you merge pull requests to master by adding a workflow file under .github/workflows/SnoopCompile.yml. This file should have content such as the example below. Lines marked with NOTE deserve special attention as likely places you may need to adjust the configuration.","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot","title":"SnoopCompile Bot","text":"name: SnoopCompile\n\non:\n  push:\n    branches:\n    #  - 'master'  # NOTE: to run the bot only on pushes to master\n\ndefaults:\n  run:\n    shell: bash\n\njobs:\n  SnoopCompile:\n    if: \"!contains(github.event.head_commit.message, '[skip ci]')\"\n    runs-on: ${{ matrix.os }}\n    strategy:\n      fail-fast: false\n      matrix:\n        version:   # NOTE: the versions below should match those in your botconfig\n          - '1.4.2'\n          - '1.3.1'\n        os:        # NOTE: should match the os setting of your botconfig\n          - ubuntu-latest\n          - windows-latest\n          - macos-latest\n        arch:\n          - x64\n    steps:\n      - uses: actions/checkout@v2\n      - uses: julia-actions/setup-julia@latest\n        with:\n          version: ${{ matrix.version }}\n      - name: Install dependencies\n        run: |\n          julia --project -e 'using Pkg; Pkg.instantiate();'\n          julia -e 'using Pkg; Pkg.add(PackageSpec(url = \"https://github.com/timholy/SnoopCompile.jl\")); Pkg.develop(PackageSpec(; path=pwd())); using SnoopCompile; SnoopCompile.addtestdep();'\n      - name: Generating precompile files\n        run: julia --project -e 'include(\"deps/SnoopCompile/snoop_bot.jl\")'   # NOTE: must match path\n      - name: Running Benchmark\n        run: julia --project -e 'include(\"deps/SnoopCompile/snoop_bench.jl\")' # NOTE: optional, if have benchmark file\n      - name: Upload all\n        uses: actions/upload-artifact@v2\n        with:\n          path: ./\n\n  Create_PR:\n    if: \"!contains(github.event.head_commit.message, '[skip ci]')\"\n    needs: SnoopCompile\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Download all\n        uses: actions/download-artifact@v2\n      - name: Move the content of the directory to the root\n        run: |\n          rsync -a artifact/* ./\n          rm -d -r artifact\n      - name: Discard unrelated changes\n        run: |\n          test -f 'Project.toml' && git checkout -- 'Project.toml'\n          git ls-files 'Manifest.toml' | grep . && git checkout -- 'Manifest.toml'\n          (git diff -w --no-color || git apply --cached --ignore-whitespace && git checkout -- . && git reset && git add -p) || echo done\n      - name: Format precompile_includer.jl\n        run: julia -e 'using Pkg; Pkg.add(\"JuliaFormatter\"); using JuliaFormatter; format_file(\"src/precompile_includer.jl\")'\n      - name: Create Pull Request\n        # https://github.com/marketplace/actions/create-pull-request\n        uses: peter-evans/create-pull-request@v2\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          commit-message: Update precompile_*.jl file\n          committer: YOUR NAME <yourEmail@something.com> # NOTE: change `committer` to your name and your email.\n          title: \"[AUTO] Update precompiles\"\n          labels: SnoopCompile\n          branch: \"SnoopCompile_AutoPR\"\n\n\n  Skip:\n    if: \"contains(github.event.head_commit.message, '[skip ci]')\"\n    runs-on: ubuntu-latest\n    steps:\n      - name: Skip CI ðŸš«\n        run: echo skip ci","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot","title":"SnoopCompile Bot","text":"You can learn more about these files and the workflow process in the documentation. Examples of such files in projects can be found in other packages, for example Zygote.","category":"page"},{"location":"bot/#","page":"SnoopCompile Bot","title":"SnoopCompile Bot","text":"note: Note\nUpgrading from an old SnoopCompile bot:In addition to the previous steps, you should also remove _precompile_() and any other code that includes a _precompile_() function. In the new version, SnoopCompile automatically creates the appropriate code.","category":"page"},{"location":"userimg/#userimg-1","page":"Creating userimg.jl files","title":"Creating userimg.jl files","text":"","category":"section"},{"location":"userimg/#","page":"Creating userimg.jl files","title":"Creating userimg.jl files","text":"If you want to save more precompile information, one option is to create a \"userimg.jl\" file with which to build Julia. This is only supported for @snoopc. Instead of calling SnoopCompile.parcel and SnoopCompile.write, use the following:","category":"page"},{"location":"userimg/#","page":"Creating userimg.jl files","title":"Creating userimg.jl files","text":"# Use these two lines if you want to add to your userimg.jl\npc = SnoopCompile.format_userimg(reverse!(data[2]))\nSnoopCompile.write(\"/tmp/userimg_Images.jl\", pc)","category":"page"},{"location":"userimg/#","page":"Creating userimg.jl files","title":"Creating userimg.jl files","text":"Now move the resulting file to your Julia source directory, and create a userimg.jl file that includes all the package-specific precompile files you want. Then build Julia from source. You should note that your latencies decrease substantially.","category":"page"},{"location":"userimg/#","page":"Creating userimg.jl files","title":"Creating userimg.jl files","text":"There are serious negatives associated with a userimg.jl script:","category":"page"},{"location":"userimg/#","page":"Creating userimg.jl files","title":"Creating userimg.jl files","text":"Your julia build times become very long\nPkg.update() will have no effect on packages that you've built into julia until you next recompile julia itself. Consequently, you may not get the benefit of enhancements or bug fixes.\nFor a package that you sometimes develop, this strategy is very inefficient, because testing a change means rebuilding Julia as well as your package.","category":"page"},{"location":"userimg/#","page":"Creating userimg.jl files","title":"Creating userimg.jl files","text":"A process similar to this one is also performed via PackageCompiler.","category":"page"},{"location":"snoopc/#macro-snoopc-1","page":"Snooping on code generation: @snoopc","title":"Snooping on code generation: @snoopc","text":"","category":"section"},{"location":"snoopc/#","page":"Snooping on code generation: @snoopc","title":"Snooping on code generation: @snoopc","text":"@snoopc has the advantage of working on any modern version of Julia. It \"snoops\" on the code-generation phase of compilation (the 'c' is a reference to code-generation). Note that while native code is not cached, it nevertheless reveals which methods are being compiled.","category":"page"},{"location":"snoopc/#","page":"Snooping on code generation: @snoopc","title":"Snooping on code generation: @snoopc","text":"Note that unlike @snoopi, @snoopc will generate all methods, not just the top-level methods that trigger compilation. (It is redundant to precompile dependent methods, but neither is it harmful.) It is also worth noting that @snoopc requires \"spinning up\" a new Julia process, and so it is a bit slower than @snoopi.","category":"page"},{"location":"snoopc/#","page":"Snooping on code generation: @snoopc","title":"Snooping on code generation: @snoopc","text":"Let's demonstrate @snoopc with a snoop script, in this case for the ColorTypes package:","category":"page"},{"location":"snoopc/#","page":"Snooping on code generation: @snoopc","title":"Snooping on code generation: @snoopc","text":"using SnoopCompile\n\n### Log the compiles\n# This only needs to be run once (to generate \"/tmp/colortypes_compiles.log\")\n\nSnoopCompile.@snoopc \"/tmp/colortypes_compiles.log\" begin\n    using ColorTypes, Pkg\n    include(joinpath(dirname(dirname(pathof(ColorTypes))), \"test\", \"runtests.jl\"))\nend\n\n### Parse the compiles and generate precompilation scripts\n# This can be run repeatedly to tweak the scripts\n\ndata = SnoopCompile.read(\"/tmp/colortypes_compiles.log\")\n\npc = SnoopCompile.parcel(reverse!(data[2]))\nSnoopCompile.write(\"/tmp/precompile\", pc)","category":"page"},{"location":"snoopc/#","page":"Snooping on code generation: @snoopc","title":"Snooping on code generation: @snoopc","text":"As with @snoopi, the \"/tmp/precompile\" folder will now contain a number of *.jl files, organized by package. For each package, you could copy its corresponding *.jl file into the package's src/ directory and include it into the package as described for @snoopi.","category":"page"},{"location":"snoopc/#","page":"Snooping on code generation: @snoopc","title":"Snooping on code generation: @snoopc","text":"There are more complete example illustrating potential options in the examples/ directory.","category":"page"},{"location":"snoopc/#Additional-flags-1","page":"Snooping on code generation: @snoopc","title":"Additional flags","text":"","category":"section"},{"location":"snoopc/#","page":"Snooping on code generation: @snoopc","title":"Snooping on code generation: @snoopc","text":"When calling the @snoopc macro, a new julia process is spawned using the function Base.julia_cmd(). Advanced users may want to tweak the flags passed to this process to suit specific needs. This can be done by passing an array of flags of the form [\"--flag1\", \"--flag2\"] as the first argument to the @snoopc macro. For instance, if you want to pass the --project=/path/to/dir flag to the process, to cause the julia process to load the project specified by the path, a snoop script may look like:","category":"page"},{"location":"snoopc/#","page":"Snooping on code generation: @snoopc","title":"Snooping on code generation: @snoopc","text":"using SnoopCompile\n\nSnoopCompile.@snoopc [\"--project=/path/to/dir\"] \"/tmp/compiles.csv\" begin\n    # ... statement to snoop on\nend\n\n# ... processing the precompile statements","category":"page"},{"location":"reference/#Reference-1","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Interactive-features-1","page":"Reference","title":"Interactive features","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"@snoopi\n@snoopc\n@snoopr\nSnoopCompile.parcel\nSnoopCompile.write\nSnoopCompile.read\nSnoopCompile.format_userimg\ntimesum\ninvalidation_trees\nfiltermod\nfindcaller","category":"page"},{"location":"reference/#SnoopCompileCore.@snoopi","page":"Reference","title":"SnoopCompileCore.@snoopi","text":"inf_timing = @snoopi commands\ninf_timing = @snoopi tmin=0.0 commands\n\nExecute commands while snooping on inference. Returns an array of (t, linfo) tuples, where t is the amount of time spent infering linfo (a MethodInstance).\n\nMethods that take less time than tmin will not be reported.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#SnoopCompileCore.@snoopc","page":"Reference","title":"SnoopCompileCore.@snoopc","text":"@snoopc \"compiledata.csv\" begin\n    # Commands to execute, in a new process\nend\n\ncauses the julia compiler to log all functions compiled in the course of executing the commands to the file \"compiledata.csv\". This file can be used for the input to SnoopCompile.read.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#SnoopCompileCore.@snoopr","page":"Reference","title":"SnoopCompileCore.@snoopr","text":"list = @snoopr expr\n\nCapture method cache invalidations triggered by evaluating expr. list is a sequence of invalidated Core.MethodInstances together with \"explanations,\" consisting of integers (encoding depth) and strings (documenting the source of an invalidation).\n\nUnless you are working at a low level, you essentially always want to pass list directly to SnoopCompileAnalysis.invalidation_trees.\n\nExtended help\n\nlist is in a format where the \"reason\" comes after the items. Method deletion results in the sequence\n\n[zero or more (mi, \"invalidate_mt_cache\") pairs..., zero or more (depth1 tree, loctag) pairs..., method, loctag] with loctag = \"jl_method_table_disable\"\n\nwhere mi means a MethodInstance. depth1 means a sequence starting at depth=1.\n\nMethod insertion results in the sequence\n\n[zero or more (depth0 tree, sig) pairs..., same info as with delete_method except loctag = \"jl_method_table_insert\"]\n\n\n\n\n\n","category":"macro"},{"location":"reference/#SnoopCompileAnalysis.parcel","page":"Reference","title":"SnoopCompileAnalysis.parcel","text":"pc = parcel(calls; subst=[], exclusions=[]) assigns each compile statement to the module that owns the function. Perform string substitution via subst=[\"Module1\"=>\"Module2\"], and omit functions in particular modules with exclusions=[\"Module3\"]. On output, pc[:Module2] contains all the precompiles assigned to Module2.\n\nUse SnoopCompile.write(prefix, pc) to generate a series of files in directory prefix, one file per module.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SnoopCompileAnalysis.write","page":"Reference","title":"SnoopCompileAnalysis.write","text":"write(prefix::AbstractString, pc::Dict; always::Bool = false)\n\nWrite each modules' precompiles to a separate file.  If always is true, the generated function will always run the precompile statements when called, otherwise the statements will only be called during package precompilation.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SnoopCompileAnalysis.read","page":"Reference","title":"SnoopCompileAnalysis.read","text":"SnoopCompile.read(\"compiledata.csv\") reads the log file produced by the compiler and returns the functions as a pair of arrays. The first array is the amount of time required to compile each function, the second is the corresponding function + types. The functions are sorted in order of increasing compilation time. (The time does not include the cost of nested compiles.)\n\n\n\n\n\n","category":"function"},{"location":"reference/#SnoopCompileAnalysis.format_userimg","page":"Reference","title":"SnoopCompileAnalysis.format_userimg","text":"pc = format_userimg(calls; subst=[], exclusions=[]) generates precompile directives intended for your base/userimg.jl script. Use SnoopCompile.write(filename, pc) to create a file that you can include into userimg.jl.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SnoopCompileBot.timesum","page":"Reference","title":"SnoopCompileBot.timesum","text":"timesum(snoop::Vector{Tuple{Float64, Core.MethodInstance}}, unit = :s)\n\nCalculates the total time measured by a snoop macro. unit can be :s or :ms.\n\nExamples\n\nusing SnoopCompile\ndata = @snoopi begin\n    using MatLang\n    MatLang_rootpath = dirname(dirname(pathof(\"MatLang\")))\n\n    include(\"$MatLang_rootpath/test/runtests.jl\")\nend\nprintln(timesum(data, :ms))\n\n\n\n\n\n","category":"function"},{"location":"reference/#SnoopCompileAnalysis.invalidation_trees","page":"Reference","title":"SnoopCompileAnalysis.invalidation_trees","text":"trees = invalidation_trees(list)\n\nParse list, as captured by SnoopCompileCore.@snoopr, into a set of invalidation trees, where parents nodes were called by their children.\n\nExample\n\njulia> f(x::Int)  = 1\nf (generic function with 1 method)\n\njulia> f(x::Bool) = 2\nf (generic function with 2 methods)\n\njulia> applyf(container) = f(container[1])\napplyf (generic function with 1 method)\n\njulia> callapplyf(container) = applyf(container)\ncallapplyf (generic function with 1 method)\n\njulia> c = Any[1]\n1-element Array{Any,1}:\n 1\n\njulia> callapplyf(c)\n1\n\njulia> trees = invalidation_trees(@snoopr f(::AbstractFloat) = 3)\n1-element Array{SnoopCompile.MethodInvalidations,1}:\n inserting f(::AbstractFloat) in Main at REPL[36]:1 invalidated:\n   mt_backedges: 1: signature Tuple{typeof(f),Any} triggered MethodInstance for applyf(::Array{Any,1}) (1 children) more specific\n\nSee the documentation for further details.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SnoopCompileAnalysis.filtermod","page":"Reference","title":"SnoopCompileAnalysis.filtermod","text":"thinned = filtermod(module, trees::AbstractVector{MethodInvalidations})\n\nSelect just the cases of invalidating a method defined in module.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SnoopCompileAnalysis.findcaller","page":"Reference","title":"SnoopCompileAnalysis.findcaller","text":"methinvs = findcaller(method::Method, trees)\n\nFind a path through trees that reaches method. Returns a single MethodInvalidations object.\n\nExamples\n\nSuppose you know that loading package SomePkg triggers invalidation of f(data). You can find the specific source of invalidation as follows:\n\nf(data)                             # run once to force compilation\nm = @which f(data)\nusing SnoopCompile\ntrees = invalidation_trees(@snoopr using SomePkg)\nmethinvs = findcaller(m, trees)\n\nIf you don't know which method to look for, but know some operation that has had added latency, you can look for methods using @snoopi. For example, suppose that loading SomePkg makes the next using statement slow. You can find the source of trouble with\n\njulia> using SnoopCompile\n\njulia> trees = invalidation_trees(@snoopr using SomePkg);\n\njulia> tinf = @snoopi using SomePkg            # this second `using` will need to recompile code invalidated above\n1-element Array{Tuple{Float64,Core.MethodInstance},1}:\n (0.08518409729003906, MethodInstance for require(::Module, ::Symbol))\n\njulia> m = tinf[1][2].def\nrequire(into::Module, mod::Symbol) in Base at loading.jl:887\n\njulia> findcaller(m, trees)\ninserting ==(x, y::SomeType) in SomeOtherPkg at /path/to/code:100 invalidated:\n   backedges: 1: superseding ==(x, y) in Base at operators.jl:83 with MethodInstance for ==(::Symbol, ::Any) (16 children) more specific\n\n\n\n\n\n","category":"function"},{"location":"reference/#Snoop-bot-1","page":"Reference","title":"Snoop bot","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"BotConfig\nsnoop_bot\nsnoop_bench","category":"page"},{"location":"reference/#SnoopCompileBot.BotConfig","page":"Reference","title":"SnoopCompileBot.BotConfig","text":"BotConfig(package_name::AbstractString ; exclusions, os, else_os, version, else_version, package_path, precompiles_rootpath, subst, tmin)\n\nConstruct a SnoopCompile bot configuration. package_name is the name of the package. This object is passed to snoop_bot and snoop_bench.\n\nYou may supply the following optional keyword arguments:\n\nexclusions : A vector of of Strings (or RegExp) to exclude some functions from being precompiled\nos: A vector of of Strings (or RegExp) to support with precompile statements.\n\nExample: os = [\"windows\", \"linux\"]\n\nelse_os: If you want to use a specific operating system's precompile file as the default, set else_os to the name of that os. Not passing this argument skips precompilation on any operating system other than those explicitly listed in os.\n\nExample: else_os = \"linux\"\n\nversion: A vector of of Julia versions used to generate precompile signatures.\n\nExample: version = [v\"1.1\", v\"1.4.2\", \"nightly\"]\n\nIt is assumed that the generated precompile signatures are valid for patch versions of Julia (e.g. giving v\"1.4.2\" supports v\"1.4.0\" to v\"1.4.9\").\n\nelse_version: the Julia version used to generate the default signatures for other versions.\n\nNot passing this argument skips precompilation on any Julia version other than those explicitly listed in version.\n\nExample: else_version = v\"1.4.2\"\n\nyml_path: instead of directly passing os and version to BotConfig, you can pass yml_path which should be the GitHub actions YAML path or file name.\n\nIt assumes that the job name is SnoopCompile.\n\nExample: yaml_path = \"SnoopCompile.yml\"\n\npackage_path: path to the main .jl file of the package (similar to pathof). Default path is pathof_noload(package_name).\nprecompiles_rootpath: the path where precompile files are stored. Default path is \"dirname(dirname(package_path))/deps/SnoopCompile/precompile\".\nsubst : A vector of pairs of Strings (or RegExp) to replace a packages precompile statements with another's package like [\"ImageTest\" => \"Images\"].\ntmin: Methods that take less time than tmin to be inferred will not be added to the precompile statements. Defaults to 0.\ncheck_eval: By default, the bot discards the precompile statements that cannot be evaled.\n\nIn rare cases (when snooping is very time consuming), you may want to do this manually by using the printed errors to add the problematic functions to exclusions and then set check_eval=false for the future runs.\n\nExample\n\nbotconfig1 = BotConfig(\n  \"Zygote\";                            # package name (the one this configuration lives in)\n  os = [\"linux\", \"windows\", \"macos\"],  # operating systems for which to precompile\n  version = [v\"1.4.2\", v\"1.3.1\"],      # supported Julia versions\n  exclusions = [\"SqEuclidean\"],         # exclude functions (by name) that would be problematic if precompiled\n)\n\nbotconfig2 = BotConfig(\n  \"Zygote\";                            # package name (the one this configuration lives in)\n  yml_path = \"SnoopCompile.yml\"        # parse `os` and `version` from `SnoopCompile.yml`\n  exclusions = [\"SqEuclidean\"],         # exclude functions (by name) that would be problematic if precompiled\n)\n\n# A full example:\nBotConfig(\"MatLang\", exclusions = [\"badfunction\"], os = [\"linux\", \"windows\", \"macos\"], else_os = \"linux\", version = [\"1.4.2\", \"1.2\", \"1.0.5\"], else_version = \"1.4.2\" )\n\n# Different examples for other possibilities:\nBotConfig(\"MatLang\")\n\nBotConfig(\"MatLang\", exclusions = [\"badfunction\"])\n\nBotConfig(\"MatLang\", os = [\"linux\", \"windows\"])\n\nBotConfig(\"MatLang\", os = [\"windows\", \"linux\"], else_os = \"linux\")\n\nBotConfig(\"MatLang\", version = [v\"1.1\", v\"1.4.2\"])\n\nBotConfig(\"MatLang\", version = [v\"1.1\", v\"1.4.2\"], else_version = v\"1.4.2\")\n\nBotConfig(\"MatLang\", os = [\"linux\", \"windows\"], version = [v\"1.1\", v\"1.4.2\"])\n\n\n\n\n\n","category":"type"},{"location":"reference/#SnoopCompileBot.snoop_bot","page":"Reference","title":"SnoopCompileBot.snoop_bot","text":"snoop_bot(config::BotConfig, path_to_example_script::String, test_modul=Main; snoop_mode=:auto)\n\nGenerate precompile statements using a precompile script. config can be generated by BotConfig. path_to_example_script is preferred to be an absolute path. The example script will be run in the module specified by test_modul. snoop_mode can be :auto, :snoopi (to run SnoopCompileCore.@snoopi), or :snoopc (to run SnoopCompileCore.@snoopc), where :auto chooses :snoopi on supported versions of Julia.\n\nSee the online documentation for a more complete overview.\n\nExtended help\n\nExample\n\nIn this case, the bot-running script is placed in the same directory as the precompile script, so we can use @__DIR__ to find it:\n\nusing SnoopCompile\n\nsnoop_bot(BotConfig(\"MatLang\"), \"$(@__DIR__)/example_script.jl\")\n\n\n\n\n\nsnoop_bot(config::BotConfig, test_modul::Module = Main)\n\nGenerate precompile statements using the package's runtests.jl file.\n\nDuring snooping, snoop_bot sets the global variable SnoopCompile_ENV to true. If needed, your runtests.jl can check for the existence and value of this variable to customize test behavior specifically for snooping.\n\n\n\n\n\nsnoop_bot(config::BotConfig, expression::Expr, test_modul::Module = Main)\n\nGenerate precompile statements by evaluating an expression, for example :(using MyPackage). Interpolation and macros are not supported.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SnoopCompileBot.snoop_bench","page":"Reference","title":"SnoopCompileBot.snoop_bench","text":"snoop_bench(config::BotConfig, path_to_example_script::String, test_modul::Module=Main; snoop_mode=:auto)\n\nBenchmark the impact of precompile statements, by running a script with and without the precompiles. config can be generated by BotConfig. path_to_example_script is preferred to be an absolute path. The example script will be run in the module specified by test_modul. snoop_mode can be :auto, :snoopi (to test with SnoopCompileCore.@snoopi), or :runtime (to measure total script run time with @timev). :auto chooses :snoopi on supported versions of Julia.\n\nSee the online documentation for a more complete overview.\n\nExtended help\n\nExample\n\nIn this case, the benchmarking script is placed in the same directory as the precompile script, so we can use @__DIR__ to find it:\n\nusing SnoopCompile\n\nsnoop_bench(BotConfig(\"MatLang\"), \"$(@__DIR__)/example_script.jl\")\n\nAs an alternative to @__DIR__ (for example, if you store your benchmarking script(s) outside the package itself), you can find the package with pathof_noload.\n\n\n\n\n\nsnoop_bench(config::BotConfig, test_modul::Module = Main)\n\nBenchmark your precompile files using the package's runtests.jl file.\n\nDuring snooping, snoop_bench sets the global variable SnoopCompile_ENV to true. If needed, your runtests.jl can check for the existence and value of this variable to customize test behavior specifically for snooping. ```\n\n\n\n\n\nsnoop_bench(config::BotConfig, expression::Expr, test_modul::Module = Main)\n\nBenchmark your precompile files by evaluating an expression, for example :(using MyPackage). Interpolation and macros are not supported.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Snoop-bot-utilities-1","page":"Reference","title":"Snoop bot utilities","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"pathof_noload","category":"page"},{"location":"reference/#SnoopCompileBot.pathof_noload","page":"Reference","title":"SnoopCompileBot.pathof_noload","text":"Returns a package's path without loading the package in the main Julia process. May launch a separate Julia process to find the package.\n\nExamples\n\npathof_noload(\"MatLang\")\n\n\n\n\n\n","category":"function"},{"location":"#SnoopCompile.jl-1","page":"SnoopCompile.jl","title":"SnoopCompile.jl","text":"","category":"section"},{"location":"#","page":"SnoopCompile.jl","title":"SnoopCompile.jl","text":"SnoopCompile \"snoops\" on the Julia compiler, causing it to record the functions and argument types it's compiling.  From these lists of methods, you can generate lists of precompile directives that may reduce the latency between loading packages and using them to do \"real work.\"","category":"page"},{"location":"#","page":"SnoopCompile.jl","title":"SnoopCompile.jl","text":"SnoopCompile can also detect and analyze method cache invalidations, which occur when new method definitions alter dispatch in a way that forces Julia to discard previously-compiled code. Any later usage of invalidated methods requires recompilation. Invalidation can trigger a domino effect, in which all users of invalidated code also become invalidated, propagating all the way back to the top-level call. When a source of invalidation can be identified and either eliminated or mitigated, you can reduce the amount of work that the compiler needs to repeat and take better advantage of precompilation.","category":"page"},{"location":"#Background-1","page":"SnoopCompile.jl","title":"Background","text":"","category":"section"},{"location":"#","page":"SnoopCompile.jl","title":"SnoopCompile.jl","text":"Julia uses Just-in-time (JIT) compilation to generate the code that runs on your CPU. Broadly speaking, there are two major steps: inference and code generation. Inference is the process of determining the type of each object, which in turn determines which specific methods get called; once type inference is complete, code generation performs optimizations and ultimately generates the assembly language (native code) used on CPUs. Some aspects of this process are documented here.","category":"page"},{"location":"#","page":"SnoopCompile.jl","title":"SnoopCompile.jl","text":"Every time you load a package in a fresh Julia session, the methods you use need to be JIT-compiled, and this contributes to the latency of using the package. In some circumstances, you can save some of the work to reduce the burden next time. This is called precompilation. Unfortunately, precompilation is not as comprehensive as one might hope. Currently, Julia is only capable of saving inference results (not native code) in the *.ji files that are the result of precompilation. Moreover, there are some significant constraints that sometimes prevent Julia from saving even the inference results; and finally, what does get saved can sometimes be invalidated if later packages provide more specific methods that supersede some of the calls in the precompiled methods.","category":"page"},{"location":"#","page":"SnoopCompile.jl","title":"SnoopCompile.jl","text":"Despite these limitations, there are cases where precompilation can substantially reduce latency. SnoopCompile is designed to try to make it easy to try precompilation to see whether it produces measurable benefits.","category":"page"},{"location":"#Who-should-use-this-package-1","page":"SnoopCompile.jl","title":"Who should use this package","text":"","category":"section"},{"location":"#","page":"SnoopCompile.jl","title":"SnoopCompile.jl","text":"SnoopCompile is intended primarily for package developers who want to improve the experience for their users. Because the results of SnoopCompile are typically stored in the *.ji precompile files, anyone can take advantage of the reduced latency.","category":"page"},{"location":"#","page":"SnoopCompile.jl","title":"SnoopCompile.jl","text":"PackageCompiler is an alternative that non-developer users may want to consider for their own workflow. It performs more thorough precompilation than the \"standard\" usage of SnoopCompile, although one can achieve a similar effect by creating userimg.jl files. However, the cost is vastly increased build times, which for package developers is unlikely to be productive.","category":"page"},{"location":"#","page":"SnoopCompile.jl","title":"SnoopCompile.jl","text":"Finally, another alternative that reduces latency without any modifications to package files is Revise. It can be used in conjunction with SnoopCompile.","category":"page"},{"location":"snoopi/#macro-snoopi-1","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"","category":"section"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"The most useful tool is a macro, @snoopi, which is only available on Julia 1.2 or higher.","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"Julia can cache inference results, so you can use @snoopi to generate precompile directives for your package. Executing these directives when the package is compiled may reduce compilation (inference) time when the package is used.","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"Here's a quick demo:","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"using SnoopCompile\n\na = rand(Float16, 5)\n\njulia> inf_timing = @snoopi sum(a)\n1-element Array{Tuple{Float64,Core.MethodInstance},1}:\n (0.011293888092041016, MethodInstance for sum(::Array{Float16,1}))","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"We defined the argument a, and then called sum(a) while \"snooping\" on inference. (The i in @snoopi means \"inference.\") The return is a list of \"top level\" methods that got compiled, together with the amount of time spent on inference. In this case it was just a single method, which required approximately 11ms of inference time. (Inferring sum required inferring all the methods that it calls, but these are subsumed into the top level inference of sum itself.) Note that the method that got called,","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"julia> @which sum(a)\nsum(a::AbstractArray) in Base at reducedim.jl:652","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"is much more general (i.e., defined for AbstractArray) than the MethodInstance (defined for Array{Float16,1}). This is because precompilation happens only for concrete objects passed as arguments.","category":"page"},{"location":"snoopi/#pcscripts-1","page":"Snooping on inference: @snoopi","title":"Precompile scripts","text":"","category":"section"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"You can use @snoopi to come up with a list of precompile-worthy functions. A recommended approach is to write a script that \"exercises\" the functionality you'd like to precompile. One option is to use your package's \"runtests.jl\" file, or you can write a custom script for this purpose. Here's an example for the FixedPointNumbers package:","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"using FixedPointNumbers\n\nx = N0f8(0.2)\ny = x + x\ny = x - x\ny = x*x\ny = x/x\ny = Float32(x)\ny = Float64(x)\ny = 0.3*x\ny = x*0.3\ny = 2*x\ny = x*2\ny = x/15\ny = x/8.0","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"Save this as a file \"snoopfpn.jl\" and navigate at the Julia REPL to that directory, and then do","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"julia> using SnoopCompile\n\njulia> inf_timing = @snoopi tmin=0.01 include(\"snoopfpn.jl\")\n2-element Array{Tuple{Float64,Core.MethodInstance},1}:\n (0.03108978271484375, MethodInstance for *(::Normed{UInt8,8}, ::Normed{UInt8,8}))\n (0.04189491271972656, MethodInstance for Normed{UInt8,8}(::Float64))","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"Here, note the tmin=0.01, which causes any methods that take less than 10ms of inference time to be discarded.","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"note: Note\nIf you're testing this, you might get different results depending on the speed of your machine. Moreover, if FixedPointNumbers has already precompiled these method and type combinationsâ€“-perhaps by incorporating a precompile file produced by SnoopCompileâ€“-then those methods will be absent. If you want to try this example, dev FixedPointNumbers and disable any _precompile_() call you find.","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"You can inspect these results and write your own precompile file, or use the automated tools provided by SnoopCompile.","category":"page"},{"location":"snoopi/#auto-1","page":"Snooping on inference: @snoopi","title":"Producing precompile directives automatically","text":"","category":"section"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"You can take the output of @snoopi and \"parcel\" it into packages:","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"julia> pc = SnoopCompile.parcel(inf_timing)\nDict{Symbol,Array{String,1}} with 1 entry:\n  :FixedPointNumbers => [\"precompile(Tuple{typeof(*),Normed{UInt8,8},Normed{UInt8,8}})\", \"precompile(Tuple{Type{Normed{UInt8,8}},Float64})\"]","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"This splits the calls up into a dictionary, pc, indexed by the package which \"owns\" each call. (In this case there is only one, FixedPointNumbers, but in more complex cases there may be several.) You can then write the results to files:","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"julia> SnoopCompile.write(\"/tmp/precompile\", pc)","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"If you look in the /tmp/precompile directory, you'll see one or more files, named by their parent package, that may be suitable for includeing into the package. In this case:","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"/tmp/precompile$ cat precompile_FixedPointNumbers.jl\nfunction _precompile_()\n    ccall(:jl_generating_output, Cint, ()) == 1 || return nothing\n    precompile(Tuple{typeof(*),Normed{UInt8,8},Normed{UInt8,8}})\n    precompile(Tuple{Type{Normed{UInt8,8}},Float64})\nend","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"If you copy this file to a precompile.jl file in the src directory, you can incorporate it into the package like this:","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"module FixedPointNumbers\n\n# All the usual commands that define the module go here\n\n# ... followed by:\n\ninclude(\"precompile.jl\")\n_precompile_()\n\nend # module FixedPointNumbers","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"The listed method/type combinations should have their inference results cached. Load the package once to precompile it, and then in a fresh Julia session try this:","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"julia> using SnoopCompile\n\njulia> inf_timing = @snoopi tmin=0.01 include(\"snoopfpn.jl\")\n0-element Array{Tuple{Float64,Core.MethodInstance},1}","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"The fact that no methods were returned is a sign of success: Julia didn't need to call inference on those methods, because it used the inference results from the cache file.","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"note: Note\nSometimes, @snoopi will show method & type combinations that you precompiled. This is a sign that despite your attempts, Julia declined to cache the inference results for those methods. You can either delete those directives from the precompile file, or hope that they will become useful in a future version of Julia. Note that having many \"useless\" precompile directives can slow down precompilation.","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"note: Note\nAs you develop your package, it's possible you'll modify or delete some of the methods that appear in your \"precompile.jl\" file. This will not result in an error; by default precompile fails silently. If you want to be certain that your precompile directives don't go stale, preface each with an @assert. Note that this forces you to update your precompile directives as you modify your package, which may or may not be desirable.","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"If you find that some precompile directives are ineffective (they appear in a new @snoopi despite being precompiled) and their inference time is substantial, sometimes a bit of manual investigation of the callees can lead to insights. For example, you might be able to introduce a precompile in a dependent package that can mitigate the total time.","category":"page"},{"location":"snoopi/#Producing-precompile-directives-manually-1","page":"Snooping on inference: @snoopi","title":"Producing precompile directives manually","text":"","category":"section"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"While this \"automated\" approach is often useful, sometimes it makes more sense to inspect the results and write your own precompile directives. For example, for FixedPointNumbers a more elegant and comprehensive precompile file might be","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"function _precompile_()\n    ccall(:jl_generating_output, Cint, ()) == 1 || return nothing\n    for T in (N0f8, N0f16)      # Normed types we want to support\n        for f in (+, -, *, /)   # operations we want to support\n            precompile(Tuple{typeof(f),T,T})\n            for S in (Float32, Float64, Int)   # other number types we want to support\n                precompile(Tuple{typeof(f),T,S})\n                precompile(Tuple{typeof(f),S,T})\n            end\n        end\n        for S in (Float32, Float64)\n            precompile(Tuple{Type{T},S})\n            precompile(Tuple{Type{S},T})\n        end\n    end\nend","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"This covers +, -, *, /, and conversion for various combinations of types. The results from @snoopi can suggest method/type combinations that might be useful to precompile, but often you can generalize its suggestions in useful ways.","category":"page"},{"location":"snoopi/#Analyzing-omitted-methods-1","page":"Snooping on inference: @snoopi","title":"Analyzing omitted methods","text":"","category":"section"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"There are some method signatures that cannot be precompiled. For example, suppose you have two packages, A and B, that are independent of one another. Then A.f([B.Object(1)]) cannot be precompiled, because A does not know about B.Object, and B does not know about A.f, unless both A and B get included into a third package.","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"Such problematic method signatures are removed automatically. If you want to be informed about these removals, you can use Julia's logging framework while running parcel:","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"julia> using Base.CoreLogging\n\njulia> logger = SimpleLogger(IOBuffer(), CoreLogging.Debug);\n\njulia> pc = with_logger(logger) do\n           SnoopCompile.parcel(inf_timing)\n       end\n\njulia> msgs = String(take!(logger.stream))","category":"page"},{"location":"snoopi/#","page":"Snooping on inference: @snoopi","title":"Snooping on inference: @snoopi","text":"The omitted method signatures will be logged to the string msgs.","category":"page"},{"location":"snoopr/#Snooping-on-and-fixing-invalidations:-@snoopr-1","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"","category":"section"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"note: Note\n@snoopr is available on Julia 1.6.0-DEV.154 or above, but the results can be relevant for all Julia versions.","category":"page"},{"location":"snoopr/#Recording-invalidations-1","page":"Snooping on and fixing invalidations: @snoopr","title":"Recording invalidations","text":"","category":"section"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"DocTestFilters = r\"(REPL\\[\\d+\\]|none):\\d+\"\nDocTestSetup = quote\n    using SnoopCompile\nend","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"Invalidations occur when there is a danger that new methods would supersede older methods in previously-compiled code.","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"To record the invalidations caused by defining new methods, use @snoopr from SnoopCompileCore:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"using SnoopCompileCore\ninvalidations = @snoopr begin\n # new methods definition\nend","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"and use invalidation_trees from SnoopCompileAnalysis to aggregate the information as a collection of tree structures:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"using SnoopCompileAnalysis\ntrees = invalidation_trees(invalidations)","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"We can illustrate this process with the following example:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"julia> f(::Real) = 1;\n\njulia> callf(container) = f(container[1]);\n\njulia> call2f(container) = callf(container);","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"Let's run this with different container types:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"julia> c64  = [1.0]; c32 = [1.0f0]; cabs = AbstractFloat[1.0];\n\njulia> call2f(c64)\n1\n\njulia> call2f(c32)\n1\n\njulia> call2f(cabs)\n1","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"It's important that you actually execute these methods: code doesn't get compiled until it gets run, and invalidations only affect compiled code.","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"Now we'll define a new f method, one specialized for Float64. So we can see the consequences for the compiled code, we'll make this definition while snooping on the compiler with @snoopr:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"julia> trees = invalidation_trees(@snoopr f(::Float64) = 2)\n1-element Array{SnoopCompileAnalysis.MethodInvalidations,1}:\n inserting f(::Float64) in Main at REPL[9]:1 invalidated:\n   backedges: 1: superseding f(::Real) in Main at REPL[2]:1 with MethodInstance for f(::Float64) (2 children)\n              2: superseding f(::Real) in Main at REPL[2]:1 with MethodInstance for f(::AbstractFloat) (2 children)\n   2 mt_cache","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"The list of MethodInvalidations indicates that some previously-compiled code got invalidated. In this case, \"inserting f(::Float64)\" means that a new method, for f(::Float64), was added. There were two proximal triggers for the invalidation, both of which superseded the method f(::Real). One of these had been compiled specifically for Float64, due to our call2f(c64). The other had been compiled specifically for AbstractFloat, due to our call2f(cabs).","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"You can look at these invalidation trees in greater detail:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"julia> method_invalidations = trees[1];    # invalidations stemming from a single method\n\njulia> root = method_invalidations.backedges[1]\nMethodInstance for f(::Float64) at depth 0 with 2 children\n\njulia> show(root)\nMethodInstance for f(::Float64) (2 children)\n MethodInstance for callf(::Array{Float64,1}) (1 children)\n â‹®\n\njulia> show(root; minchildren=0)\nMethodInstance for f(::Float64) (2 children)\n MethodInstance for callf(::Array{Float64,1}) (1 children)\n  MethodInstance for call2f(::Array{Float64,1}) (0 children)","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"You can see that the sequence of invalidations proceeded all the way up to call2f. Examining root2 = method_invalidations.backedges[2] yields similar results, but for Array{AbstractFloat,1}.","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"The structure of these trees can be considerably more complicated. For example, if callf also got called by some other method, and that method had also been executed (forcing it to be compiled), then callf would have multiple children. This is often seen with more complex, real-world tests:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"julia> trees = invalidation_trees(@snoopr using SIMD)\n4-element Array{SnoopCompileAnalysis.MethodInvalidations,1}:\n inserting convert(::Type{Tuple{Vararg{R,N}}}, v::Vec{N,T}) where {N, R, T} in SIMD at /home/tim/.julia/packages/SIMD/Am38N/src/SIMD.jl:182 invalidated:\n   mt_backedges: 1: signature Tuple{typeof(convert),Type{Tuple{DataType,DataType,DataType}},Any} triggered MethodInstance for Pair{DataType,Tuple{DataType,DataType,DataType}}(::Any, ::Any) (0 children)\n                 2: signature Tuple{typeof(convert),Type{NTuple{8,DataType}},Any} triggered MethodInstance for Pair{DataType,NTuple{8,DataType}}(::Any, ::Any) (0 children)\n                 3: signature Tuple{typeof(convert),Type{NTuple{7,DataType}},Any} triggered MethodInstance for Pair{DataType,NTuple{7,DataType}}(::Any, ::Any) (0 children)\n\n inserting convert(::Type{Tuple}, v::Vec{N,T}) where {N, T} in SIMD at /home/tim/.julia/packages/SIMD/Am38N/src/SIMD.jl:188 invalidated:\n   mt_backedges: 1: signature Tuple{typeof(convert),Type{Tuple},Any} triggered MethodInstance for Distributed.RemoteDoMsg(::Any, ::Any, ::Any) (1 children)\n                 2: signature Tuple{typeof(convert),Type{Tuple},Any} triggered MethodInstance for Distributed.CallMsg{:call}(::Any, ::Any, ::Any) (1 children)\n                 3: signature Tuple{typeof(convert),Type{Tuple},Any} triggered MethodInstance for Distributed.CallMsg{:call_fetch}(::Any, ::Any, ::Any) (1 children)\n                 4: signature Tuple{typeof(convert),Type{Tuple},Any} triggered MethodInstance for Distributed.CallWaitMsg(::Any, ::Any, ::Any) (4 children)\n   12 mt_cache\n\n inserting <<(x1::T, v2::Vec{N,T}) where {N, T<:Union{Bool, Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}} in SIMD at /home/tim/.julia/packages/SIMD/Am38N/src/SIMD.jl:1061 invalidated:\n   mt_backedges: 1: signature Tuple{typeof(<<),UInt64,Any} triggered MethodInstance for <<(::UInt64, ::Integer) (0 children)\n                 2: signature Tuple{typeof(<<),UInt64,Any} triggered MethodInstance for copy_chunks_rtol!(::Array{UInt64,1}, ::Integer, ::Integer, ::Integer) (0 children)\n                 3: signature Tuple{typeof(<<),UInt64,Any} triggered MethodInstance for copy_chunks_rtol!(::Array{UInt64,1}, ::Int64, ::Int64, ::Integer) (0 children)\n                 4: signature Tuple{typeof(<<),UInt64,Any} triggered MethodInstance for copy_chunks_rtol!(::Array{UInt64,1}, ::Integer, ::Int64, ::Integer) (0 children)\n                 5: signature Tuple{typeof(<<),UInt64,Any} triggered MethodInstance for <<(::UInt64, ::Unsigned) (16 children)\n   20 mt_cache\n\n inserting +(s1::Union{Bool, Float16, Float32, Float64, Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8, Ptr}, v2::Vec{N,T}) where {N, T<:Union{Float16, Float32, Float64}} in SIMD at /home/tim/.julia/packages/SIMD/Am38N/src/SIMD.jl:1165 invalidated:\n   mt_backedges:  1: signature Tuple{typeof(+),Ptr{UInt8},Any} triggered MethodInstance for handle_err(::JuliaInterpreter.Compiled, ::JuliaInterpreter.Frame, ::Any) (0 children)\n                  2: signature Tuple{typeof(+),Ptr{UInt8},Any} triggered MethodInstance for #methoddef!#5(::Bool, ::typeof(LoweredCodeUtils.methoddef!), ::Any, ::Set{Any}, ::JuliaInterpreter.Frame) (0 children)\n                  3: signature Tuple{typeof(+),Ptr{UInt8},Any} triggered MethodInstance for #get_def#94(::Set{Tuple{Revise.PkgData,String}}, ::typeof(Revise.get_def), ::Method) (0 children)\n                  4: signature Tuple{typeof(+),Ptr{Nothing},Any} triggered MethodInstance for filter_valid_cachefiles(::String, ::Array{String,1}) (0 children)\n                  5: signature Tuple{typeof(+),Ptr{Union{Int64, Symbol}},Any} triggered MethodInstance for pointer(::Array{Union{Int64, Symbol},N} where N, ::Int64) (1 children)\n                  6: signature Tuple{typeof(+),Ptr{Char},Any} triggered MethodInstance for pointer(::Array{Char,N} where N, ::Int64) (2 children)\n                  7: signature Tuple{typeof(+),Ptr{_A} where _A,Any} triggered MethodInstance for pointer(::Array{T,N} where N where T, ::Int64) (4 children)\n                  8: signature Tuple{typeof(+),Ptr{Nothing},Any} triggered MethodInstance for _show_default(::IOContext{Base.GenericIOBuffer{Array{UInt8,1}}}, ::Any) (49 children)\n                  9: signature Tuple{typeof(+),Ptr{Nothing},Any} triggered MethodInstance for _show_default(::Base.GenericIOBuffer{Array{UInt8,1}}, ::Any) (336 children)\n                 10: signature Tuple{typeof(+),Ptr{UInt8},Any} triggered MethodInstance for pointer(::String, ::Integer) (1027 children)\n   2 mt_cache\n","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"Your specific output will surely be different from this, depending on which packages you have loaded, which versions of those packages are installed, and which version of Julia you are using. In this example, there were four different methods that triggered invalidations, and the invalidated methods were in Base, Distributed, JuliaInterpeter, and LoweredCodeUtils. (The latter two were a consequence of loading Revise.) You can see that collectively more than a thousand independent compiled methods needed to be invalidated; indeed, the last entry alone invalidates 1027 method instances:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"julia> sig, root = trees[end].mt_backedges[10]\nPair{Any,SnoopCompile.InstanceNode}(Tuple{typeof(+),Ptr{UInt8},Any}, MethodInstance for pointer(::String, ::Integer) at depth 0 with 1027 children)\n\njulia> root\nMethodInstance for pointer(::String, ::Integer) at depth 0 with 1027 children\n\njulia> show(root)\nMethodInstance for pointer(::String, ::Integer) (1027 children)\n MethodInstance for repeat(::String, ::Integer) (1023 children)\n  MethodInstance for ^(::String, ::Integer) (1019 children)\n   MethodInstance for #handle_message#2(::Nothing, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(Base.CoreLogging.handle_message), ::Logging.ConsoleLogger, ::Base.CoreLogging.LogLevel, ::String, ::Module, ::Symbol, ::Symbol, ::String, ::Int64) (906 children)\n    MethodInstance for handle_message(::Logging.ConsoleLogger, ::Base.CoreLogging.LogLevel, ::String, ::Module, ::Symbol, ::Symbol, ::String, ::Int64) (902 children)\n     MethodInstance for log_event_global!(::Pkg.Resolve.Graph, ::String) (35 children)\n     â‹®\n     MethodInstance for #artifact_meta#20(::Pkg.BinaryPlatforms.Platform, ::typeof(Pkg.Artifacts.artifact_meta), ::String, ::Dict{String,Any}, ::String) (43 children)\n     â‹®\n     MethodInstance for Dict{Base.UUID,Pkg.Types.PackageEntry}(::Dict) (79 children)\n     â‹®\n     MethodInstance for read!(::Base.Process, ::LibGit2.GitCredential) (80 children)\n     â‹®\n     MethodInstance for handle_err(::JuliaInterpreter.Compiled, ::JuliaInterpreter.Frame, ::Any) (454 children)\n     â‹®\n    â‹®\n   â‹®\n  â‹®\n â‹®\nâ‹®","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"Many nodes in this tree have multiple \"child\" branches.","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"note: Note\nThese trees are sorted so that the last items have the largest number of children. It works this way so that long printouts don't have the most important information scroll off the top of the screen.","category":"page"},{"location":"snoopr/#Filtering-invalidations-1","page":"Snooping on and fixing invalidations: @snoopr","title":"Filtering invalidations","text":"","category":"section"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"Some methods trigger widespread invalidation. If you don't have time to fix all of them, you might want to focus on a specific set of invalidations. For instance, you might be the author of PkgA and you've noted that loading PkgB invalidates a lot of PkgA's code. In that case, you might want to find just those invalidations triggered in your package. You can find them with filtermod:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"trees = invalidation_trees(@snoopr using PkgB)\nftrees = filtermod(PkgA, trees)","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"filtermod only selects trees where the root method was defined in the specified module.","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"A more selective yet exhaustive tool is findcaller, which allows you to find the path through the trees to a particular method:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"f(data)                             # run once to force compilation\nm = @which f(data)\nusing SnoopCompile\ntrees = invalidation_trees(@snoopr using SomePkg)\ninvs = findcaller(m, trees)","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"When you don't know which method to choose, but know an operation that got slowed down by loading SomePkg, you can use @snoopi to find methods that needed to be recompiled. See findcaller for further details.","category":"page"},{"location":"snoopr/#Avoiding-or-fixing-invalidations-1","page":"Snooping on and fixing invalidations: @snoopr","title":"Avoiding or fixing invalidations","text":"","category":"section"},{"location":"snoopr/#Tools-for-fixing-invalidations:-ascend-1","page":"Snooping on and fixing invalidations: @snoopr","title":"Tools for fixing invalidations: ascend","text":"","category":"section"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"SnoopCompile, partnering with the remarkable Cthulhu.jl, provides a tool called ascend to simplify diagnosing and fixing invalidations. To demonstrate this tool, let's use it on our call2f method_invalidations tree from above. We start with","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"julia> root = method_invalidations.backedges[end]\nMethodInstance for f(::AbstractFloat) at depth 0 with 2 children","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"(It's common to start from the last element of backedges or mt_backedges since these have the largest number of children and are therefore most consequential.) Then:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"julia> ascend(root)\nChoose a call for analysis (q to quit):\n >   f(::AbstractFloat)\n       callf(::Array{AbstractFloat,1})\n         call2f(::Array{AbstractFloat,1})","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"This is an interactive menu: press the down arrow to go down, the up arrow to go up, and Enter to select an item for more detailed analysis. In large trees, you may also want to \"fold\" nodes of the tree (collapsing it so that the children are no longer displayed), particularly if you are working your way through a long series of invalidations and want to hide ones you've already dealt with. You toggle folding using the space bar, and folded nodes are printed with a + in front of them.","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"For example, if we press the down arrow once, we get","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"julia> ascend(root)\nChoose a call for analysis (q to quit):\n     f(::AbstractFloat)\n >     callf(::Array{AbstractFloat,1})\n         call2f(::Array{AbstractFloat,1})","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"Now hit Enter to select it:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"Choose caller of MethodInstance for f(::AbstractFloat) or proceed to typed code:\n > \"REPL[3]\", callf: lines [1]\n   Browse typed code","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"This is showing you another menu, with only two option (a third is to go back by hitting q). The first entry shows you the option to open the \"offending\" source file in callf at the position of the call to the parent node of callf, which in this case is f. (Sometimes there will be more than one call to the parent within the method, in which case instead of showing [1] it might show [1, 17, 39] indicating each separate location.) While in this case this isn't useful (methods defined in the REPL are not supported), selecting this option, when available, is typically the best way to start because you can sometimes resolve the problem from this information alone.","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"If you hit the down arrow","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"Choose caller of MethodInstance for f(::AbstractFloat) or proceed to typed code:\n   \"REPL[3]\", callf: lines [1]\n > Browse typed code","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"and then hit Enter, this is what you see:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"â”‚ â”€ %-1  = invoke callf(::Array{AbstractFloat,1})::Int64\nVariables\n  #self#::Core.Compiler.Const(callf, false)\n  container::Array{AbstractFloat,1}\n\nBody::Int64\n    @ REPL[3]:1 within callf\n1 â”€ %1 = Base.getindex(container, 1)::AbstractFloat\nâ”‚   %2 = Main.f(%1)::Int64\nâ””â”€â”€      return %2\n\nSelect a call to descend into or â†© to ascend. [q]uit. [b]ookmark.\nToggles: [o]ptimize, [w]arn, [d]ebuginfo, [s]yntax highlight for Source/LLVM/Native.\nShow: [S]ource code, [A]ST, [L]LVM IR, [N]ative code\nAdvanced: dump [P]arams cache.\n\n â€¢ %1  = invoke getindex(::Array{AbstractFloat,1},::Int64)::AbstractFloat\n   %2  = call #f(::AbstractFloat)::Int64\n   â†©","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"This is output from Cthulhu, and you should see its documentation for more information. (See also this video.) While it takes a bit of time to master Cthulhu, it is an exceptionally powerful tool for diagnosing and fixing inference issues.","category":"page"},{"location":"snoopr/#Tips-for-fixing-invalidations-1","page":"Snooping on and fixing invalidations: @snoopr","title":"Tips for fixing invalidations","text":"","category":"section"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"Invalidations occur in situations like our call2f(c64) example, where we changed our mind about what value f should return for Float64. Julia could not have returned the newly-correct answer without recompiling the call chain.","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"Aside from cases like these, most invalidations occur whenever new types are introduced, and some methods were previously compiled for abstract types. In some cases, this is inevitable, and the resulting invalidations simply need to be accepted as a consequence of a dynamic, updateable language. (You can often minimize invalidations by loading all your code at the beginning of your session, before triggering the compilation of more methods.) However, in many circumstances an invalidation indicates an opportunity to improve code. In our first example, note that the call call2f(c32) did not get invalidated: this is because the compiler knew all the specific types, and new methods did not affect any of those types. The main tips for writing invalidation-resistant code are:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"use concrete types wherever possible\nwrite inferrable code\ndon't engage in type-piracy (our c64 example is essentially like type-piracy, where we redefined behavior for a pre-existing type)","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"Since these tips also improve performance and allow programs to behave more predictably, these guidelines are not intrusive. Indeed, searching for and eliminating invalidations can help you improve the quality of your code. In cases where invalidations occur, but you can't use concrete types (there are many valid uses of Vector{Any}), you can often prevent the invalidation using some additional knowledge. For example, suppose you're writing code that parses Julia's Expr type:","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"julia> ex = :(Array{Float32,3})\n:(Array{Float32, 3})\n\njulia> dump(ex)\nExpr\n  head: Symbol curly\n  args: Array{Any}((3,))\n    1: Symbol Array\n    2: Symbol Float32\n    3: Int64 3","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"ex.args is a Vector{Any}. However, for a :curly expression only certain types will be found among the arguments; you could write key portions of your code as","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"a = ex.args[2]\nif a isa Symbol\n    # inside this block, Julia knows `a` is a Symbol, and so methods called on `a` will be resistant to invalidation\n    foo(a)\nelseif a isa Expr && length((a::Expr).args) > 2\n    a = a::Expr     # sometimes you have to help inference by adding a type-assert\n    x = bar(a)      # `bar` is now resistant to invalidation\nelsef a isa Integer\n    # even though you've not made this fully-inferrable, you've at least reduced the scope for invalidations\n    # by limiting the subset of `foobar` methods that might be called\n    y = foobar(a)\nend","category":"page"},{"location":"snoopr/#","page":"Snooping on and fixing invalidations: @snoopr","title":"Snooping on and fixing invalidations: @snoopr","text":"Adding type-assertions and fixing inference problems are the most common approaches for fixing invalidations. You can discover these manually, but using Cthulhu is highly recommended.","category":"page"}]
}
