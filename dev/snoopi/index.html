<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Snooping on inference: @snoopi · SnoopCompile</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">SnoopCompile</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">SnoopCompile.jl</a></li><li class="is-active"><a class="tocitem" href>Snooping on inference: <code>@snoopi</code></a><ul class="internal"><li><a class="tocitem" href="#Precompile-scripts-1"><span>Precompile scripts</span></a></li><li><a class="tocitem" href="#auto-1"><span>Producing precompile directives automatically</span></a></li><li><a class="tocitem" href="#Producing-precompile-directives-manually-1"><span>Producing precompile directives manually</span></a></li><li><a class="tocitem" href="#Analyzing-omitted-methods-1"><span>Analyzing omitted methods</span></a></li></ul></li><li><a class="tocitem" href="../snoopc/">Snooping on code generation: <code>@snoopc</code></a></li><li><a class="tocitem" href="../userimg/">Creating <code>userimg.jl</code> files</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Snooping on inference: <code>@snoopi</code></a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Snooping on inference: <code>@snoopi</code></a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/timholy/SnoopCompile.jl/blob/master/docs/src/snoopi.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Snooping-on-inference:-@snoopi-1"><a class="docs-heading-anchor" href="#Snooping-on-inference:-@snoopi-1">Snooping on inference: <code>@snoopi</code></a><a class="docs-heading-anchor-permalink" href="#Snooping-on-inference:-@snoopi-1" title="Permalink"></a></h1><p>The most useful tool is a macro, <code>@snoopi</code>, which is only available on Julia 1.2 or higher.</p><p>Julia can cache inference results, so you can use <code>@snoopi</code> to generate <code>precompile</code> directives for your package. Executing these directives when the package is compiled may reduce compilation (inference) time when the package is used.</p><p>Here&#39;s a quick demo:</p><pre><code class="language-julia">using SnoopCompile

a = rand(Float16, 5)

julia&gt; inf_timing = @snoopi sum(a)
1-element Array{Tuple{Float64,Core.MethodInstance},1}:
 (0.011293888092041016, MethodInstance for sum(::Array{Float16,1}))</code></pre><p>We defined the argument <code>a</code>, and then called <code>sum(a)</code> while &quot;snooping&quot; on inference. (The <code>i</code> in <code>@snoopi</code> means &quot;inference.&quot;) The return is a list of &quot;top level&quot; methods that got compiled, together with the amount of time spent on inference. In this case it was just a single method, which required approximately 11ms of inference time. (Inferring <code>sum</code> required inferring all the methods that it calls, but these are subsumed into the top level inference of <code>sum</code> itself.) Note that the method that got called,</p><pre><code class="language-julia">julia&gt; @which sum(a)
sum(a::AbstractArray) in Base at reducedim.jl:652</code></pre><p>is much more general (i.e., defined for <code>AbstractArray</code>) than the <code>MethodInstance</code> (defined for <code>Array{Float16,1}</code>). This is because precompilation happens only for concrete objects passed as arguments.</p><h2 id="Precompile-scripts-1"><a class="docs-heading-anchor" href="#Precompile-scripts-1">Precompile scripts</a><a class="docs-heading-anchor-permalink" href="#Precompile-scripts-1" title="Permalink"></a></h2><p>You can use <code>@snoopi</code> to come up with a list of precompile-worthy functions. A recommended approach is to write a script that &quot;exercises&quot; the functionality you&#39;d like to precompile. One option is to use your package&#39;s <code>&quot;runtests.jl&quot;</code> file, or you can write a custom script for this purpose. Here&#39;s an example for the <a href="https://github.com/JuliaMath/FixedPointNumbers.jl">FixedPointNumbers package</a>:</p><pre><code class="language-none">using FixedPointNumbers

x = N0f8(0.2)
y = x + x
y = x - x
y = x*x
y = x/x
y = Float32(x)
y = Float64(x)
y = 0.3*x
y = x*0.3
y = 2*x
y = x*2
y = x/15
y = x/8.0</code></pre><p>Save this as a file <code>&quot;snoopfpn.jl&quot;</code> and navigate at the Julia REPL to that directory, and then do</p><pre><code class="language-julia">julia&gt; using SnoopCompile

julia&gt; inf_timing = @snoopi tmin=0.01 include(&quot;snoopfpn.jl&quot;)
2-element Array{Tuple{Float64,Core.MethodInstance},1}:
 (0.03108978271484375, MethodInstance for *(::Normed{UInt8,8}, ::Normed{UInt8,8}))
 (0.04189491271972656, MethodInstance for Normed{UInt8,8}(::Float64))             </code></pre><p>Here, note the <code>tmin=0.01</code>, which causes any methods that take less than 10ms of inference time to be discarded.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If you&#39;re testing this, you might get different results depending on the speed of your machine. Moreover, if FixedPointNumbers has already precompiled these method and type combinations–-perhaps by incorporating a precompile file produced by SnoopCompile–-then those methods will be absent. If you want to try this example, <code>dev FixedPointNumbers</code> and disable any <code>_precompile_()</code> call you find.</p></div></div><p>You can inspect these results and write your own precompile file, or use the automated tools provided by SnoopCompile.</p><h2 id="auto-1"><a class="docs-heading-anchor" href="#auto-1">Producing precompile directives automatically</a><a class="docs-heading-anchor-permalink" href="#auto-1" title="Permalink"></a></h2><p>You can take the output of <code>@snoopi</code> and &quot;parcel&quot; it into packages:</p><pre><code class="language-julia">julia&gt; pc = SnoopCompile.parcel(inf_timing)
Dict{Symbol,Array{String,1}} with 1 entry:
  :FixedPointNumbers =&gt; [&quot;precompile(Tuple{typeof(*),Normed{UInt8,8},Normed{UInt8,8}})&quot;, &quot;precompile(Tuple{Type{Normed{UInt8,8}},Float64})&quot;]</code></pre><p>This splits the calls up into a dictionary, <code>pc</code>, indexed by the package which &quot;owns&quot; each call. (In this case there is only one, <code>FixedPointNumbers</code>, but in more complex cases there may be several.) You can then write the results to files:</p><pre><code class="language-julia">julia&gt; SnoopCompile.write(&quot;/tmp/precompile&quot;, pc)</code></pre><p>If you look in the <code>/tmp/precompile</code> directory, you&#39;ll see one or more files, named by their parent package, that may be suitable for <code>include</code>ing into the package. In this case:</p><pre><code class="language-none">/tmp/precompile$ cat precompile_FixedPointNumbers.jl
function _precompile_()
    ccall(:jl_generating_output, Cint, ()) == 1 || return nothing
    precompile(Tuple{typeof(*),Normed{UInt8,8},Normed{UInt8,8}})
    precompile(Tuple{Type{Normed{UInt8,8}},Float64})
end</code></pre><p>If you copy this file to a <code>precompile.jl</code> file in the <code>src</code> directory, you can incorporate it into the package like this:</p><pre><code class="language-julia">module FixedPointNumbers

# All the usual commands that define the module go here

# ... followed by:

include(&quot;precompile.jl&quot;)
_precompile_()

end # module FixedPointNumbers</code></pre><p>The listed method/type combinations should have their inference results cached. Load the package once to precompile it, and then in a fresh Julia session try this:</p><pre><code class="language-julia">julia&gt; using SnoopCompile

julia&gt; inf_timing = @snoopi tmin=0.01 include(&quot;snoopfpn.jl&quot;)
0-element Array{Tuple{Float64,Core.MethodInstance},1}</code></pre><p>The fact that no methods were returned is a sign of success: Julia didn&#39;t need to call inference on those methods, because it used the inference results from the cache file.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Sometimes, <code>@snoopi</code> will show method &amp; type combinations that you precompiled. This is a sign that despite your attempts, Julia declined to cache the inference results for those methods. You can either delete those directives from the precompile file, or hope that they will become useful in a future version of Julia. Note that having many &quot;useless&quot; precompile directives can slow down precompilation.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>As you develop your package, it&#39;s possible you&#39;ll modify or delete some of the methods that appear in your <code>&quot;precompile.jl&quot;</code> file. This will <em>not</em> result in an error; by default <code>precompile</code> fails silently. If you want to be certain that your precompile directives don&#39;t go stale, preface each with an <code>@assert</code>. Note that this forces you to update your precompile directives as you modify your package, which may or may not be desirable.</p></div></div><p>The statements appear in the precompile file in order of inference time, with the first methods taking the longest to precompile. If you find that some precompile directives are ineffective (they appear in a new <code>@snoopi</code> despite being precompiled) and their inference time is substantial, sometimes a bit of manual investigation of the callees can lead to insights. For example, you might be able to introduce a precompile in a dependent package) that can mitigate the total time.</p><h2 id="Producing-precompile-directives-manually-1"><a class="docs-heading-anchor" href="#Producing-precompile-directives-manually-1">Producing precompile directives manually</a><a class="docs-heading-anchor-permalink" href="#Producing-precompile-directives-manually-1" title="Permalink"></a></h2><p>While this &quot;automated&quot; approach is often useful, sometimes it makes more sense to inspect the results and write your own precompile directives. For example, for FixedPointNumbers a more elegant and comprehensive precompile file might be</p><pre><code class="language-julia">function _precompile_()
    ccall(:jl_generating_output, Cint, ()) == 1 || return nothing
    for T in (N0f8, N0f16)      # Normed types we want to support
        for f in (+, -, *, /)   # operations we want to support
            precompile(Tuple{typeof(f),T,T})
            for S in (Float32, Float64, Int)   # other number types we want to support
                precompile(Tuple{typeof(f),T,S})
                precompile(Tuple{typeof(f),S,T})
            end
        end
        for S in (Float32, Float64)
            precompile(Tuple{Type{T},S})
            precompile(Tuple{Type{S},T})
        end
    end
end</code></pre><p>This covers <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, and conversion for various combinations of types. The results from <code>@snoopi</code> can suggest method/type combinations that might be useful to precompile, but often you can generalize its suggestions in useful ways.</p><h2 id="Analyzing-omitted-methods-1"><a class="docs-heading-anchor" href="#Analyzing-omitted-methods-1">Analyzing omitted methods</a><a class="docs-heading-anchor-permalink" href="#Analyzing-omitted-methods-1" title="Permalink"></a></h2><p>There are some methods that cannot be precompiled. For example, suppose you have two packages, <code>A</code> and <code>B</code>, that are independent of one another. Then <code>A.f([B.Object(1)])</code> cannot be precompiled, because <code>A</code> does not know about <code>B.Object</code>, and <code>B</code> does not know about <code>A.f</code>, unless both <code>A</code> and <code>B</code> get included into another package.</p><p>Such problematic methods are removed automatically. If you want to be informed about these removals, you can use Julia&#39;s logging framework while running <code>parcel</code>:</p><pre><code class="language-none">julia&gt; using Base.CoreLogging

julia&gt; logger = SimpleLogger(IOBuffer(), CoreLogging.Debug);

julia&gt; pc = with_logger(logger) do
           SnoopCompile.parcel(inf_timing)
       end

julia&gt; msgs = String(take!(logger.stream))</code></pre><p>The omitted methods will be logged to the string <code>msgs</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« SnoopCompile.jl</a><a class="docs-footer-nextpage" href="../snoopc/">Snooping on code generation: <code>@snoopc</code> »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 8 December 2019 00:06">Sunday 8 December 2019</span>. Using Julia version 1.3.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
